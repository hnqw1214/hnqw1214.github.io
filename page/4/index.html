<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="acmclub.win">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="acmclub.win">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="acmclub.win">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>acmclub.win</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">acmclub.win</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/archives"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/Codeforces-761E（DFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/Codeforces-761E（DFS/" itemprop="url">
                  Codeforces 761E（DFS)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:42:03-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Dasha decided to have a rest after solving the problem. She had been ready to start her favourite activity — origami, but remembered the puzzle that she could not solve.<br>The tree is a non-oriented connected graph without cycles. In particular, there always are n - 1 edges in a tree with n vertices.</p>
<p>The puzzle is to position the vertices at the points of the Cartesian plane with integral coordinates, so that the segments between the vertices connected by edges are parallel to the coordinate axes. Also, the intersection of segments is allowed only at their ends. Distinct vertices should be placed at different points. </p>
<p>Help Dasha to find any suitable way to position the tree vertices on the plane.</p>
<p>It is guaranteed that if it is possible to position the tree vertices on the plane without violating the condition which is given above, then you can do it by using points with integral coordinates which don’t exceed 1018 in absolute value.</p>
<p>Input<br>The first line contains single integer n (1 ≤ n ≤ 30) — the number of vertices in the tree. </p>
<p>Each of next n - 1 lines contains two integers ui, vi (1 ≤ ui, vi ≤ n) that mean that the i-th edge of the tree connects vertices ui and vi.</p>
<p>It is guaranteed that the described graph is a tree.</p>
<p>Output<br>If the puzzle doesn’t have a solution then in the only line print “NO”.</p>
<p>Otherwise, the first line should contain “YES”. The next n lines should contain the pair of integers xi, yi (|xi|, |yi| ≤ 1018) — the coordinates of the point which corresponds to the i-th vertex of the tree.</p>
<p>If there are several solutions, print any of them. </p>
<p>Examples<br>input<br>7<br>1 2<br>1 3<br>2 4<br>2 5<br>3 6<br>3 7<br>output<br>YES<br>0 0<br>1 0<br>0 1<br>2 0<br>1 -1<br>-1 1<br>0 2<br>input<br>6<br>1 2<br>2 3<br>2 4<br>2 5<br>2 6<br>output<br>NO<br>input<br>4<br>1 2<br>2 3<br>3 4<br>output<br>YES<br>3 3<br>4 3<br>5 3<br>6 3</p>
<p>直接向4个方向模拟按长度从大到小DFS即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">101</span>];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> ansx[<span class="number">101</span>],ansy[<span class="number">101</span>];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[<span class="number">41</span>];</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> d1[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> d2[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">int</span> d,<span class="keyword">int</span> cnt)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</div><div class="line">    <span class="keyword">for</span> (iter=a[x].begin();iter!=a[x].end();iter++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> y=*iter;</div><div class="line">        <span class="keyword">if</span> (y==fa) <span class="keyword">continue</span>;</div><div class="line">        ansx[y]=ansx[x]+d1[(d+<span class="number">3</span>)%<span class="number">4</span>]*p[cnt];</div><div class="line">        ansy[y]=ansy[x]+d2[(d+<span class="number">3</span>)%<span class="number">4</span>]*p[cnt];</div><div class="line">        dfs(y,x,(d+<span class="number">3</span>)%<span class="number">4</span>,cnt<span class="number">-1</span>);</div><div class="line">        d++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    p[<span class="number">0</span>]=<span class="number">1l</span>l;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">40</span>;i++) p[i]=p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> x,y;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</div><div class="line">        a[x].push_back(y);</div><div class="line">        a[y].push_back(x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">if</span> (a[i].size()&gt;<span class="number">4</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">40</span>);</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,ansx[i],ansy[i]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/Codeforces-777E（离散化-dp-树状数组或线段树维护最大值）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/Codeforces-777E（离散化-dp-树状数组或线段树维护最大值）/" itemprop="url">
                  Codeforces 777E（离散化+dp+树状数组或线段树维护最大值）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:41:08-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Of course you have heard the famous task about Hanoi Towers, but did you know that there is a special factory producing the rings for this wonderful game? Once upon a time, the ruler of the ancient Egypt ordered the workers of Hanoi Factory to create as high tower as possible. They were not ready to serve such a strange order so they had to create this new tower using already produced rings.</p>
<p>There are n rings in factory’s stock. The i-th ring has inner radius ai, outer radius bi and height hi. The goal is to select some subset of rings and arrange them such that the following conditions are satisfied:</p>
<p>Outer radiuses form a non-increasing sequence, i.e. one can put the j-th ring on the i-th ring only if bj ≤ bi.<br>Rings should not fall one into the the other. That means one can place ring j on the ring i only if bj &gt; ai.<br>The total height of all rings used should be maximum possible.<br>Input<br>The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of rings in factory’s stock.</p>
<p>The i-th of the next n lines contains three integers ai, bi and hi (1 ≤ ai, bi, hi ≤ 109, bi &gt; ai) — inner radius, outer radius and the height of the i-th ring respectively.</p>
<p>Output<br>Print one integer — the maximum height of the tower that can be obtained.</p>
<p>Examples<br>input<br>3<br>1 5 1<br>2 6 2<br>3 7 3<br>output<br>6<br>input<br>4<br>1 2 1<br>1 3 3<br>4 6 2<br>5 7 1<br>output<br>4<br>Note<br>In the first sample, the optimal solution is to take all the rings and put them on each other in order 3, 2, 1.</p>
<p>In the second sample, one can put the ring 3 on the ring 4 and get the tower of height 3, or put the ring 1 on the ring 2 and get the tower of height 4.</p>
<p>因a和b数组中的数较大，因此需要离散化。可以用类似于LIS的方法进行dp转移，但因为题目要求时间复杂度为O（nlogn），所以还要用树状数组或线段树进行优化，维护1到某个半径的最大高度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ss</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</div><div class="line">&#125;;</div><div class="line">ss a[<span class="number">3000001</span>];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,len,tree[<span class="number">3000001</span>],m=<span class="number">0</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> :</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;    <span class="comment">//离散化</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        sort(begin(), end());</div><div class="line">        <span class="comment">//erase(unique(begin(), end()), end());</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lower_bound(begin(), end(), x)-begin()+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125; has;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (;x&lt;=m;x+=x&amp;(-x)) tree[x]=max(tree[x],y);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;x;x-=x&amp;(-x)) p=max(p,tree[x]);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ss a,ss b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (a.b&gt;b.b||a.b==b.b&amp;&amp;a.a&gt;b.a);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i].a,&amp;a[i].b,&amp;a[i].c);</div><div class="line">    has.clear();</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        has.push_back(a[i].a),has.push_back(a[i].b);</div><div class="line">    has.prepare();</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        a[i].a=has.get(a[i].a),a[i].b=has.get(a[i].b),m=max(a[i].b,m);</div><div class="line">    m*=<span class="number">2</span>;</div><div class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</div><div class="line">    <span class="comment">//for (i=1;i&lt;=n;i++)</span></div><div class="line">    <span class="comment">//    printf("%d %d %d\n",a[i].a,a[i].b,a[i].c);</span></div><div class="line">    <span class="comment">//cout&lt;&lt;m&lt;&lt;endl;</span></div><div class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> now=sum(a[i].b<span class="number">-1</span>)+a[i].c;</div><div class="line">        <span class="comment">//cout&lt;&lt;sum(a[i].b-1)&lt;&lt;endl;</span></div><div class="line">        upd(a[i].a,now);</div><div class="line">        ans=max(ans,now);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/4300-绝世好题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/4300-绝世好题/" itemprop="url">
                  4300: 绝世好题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:35:09-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个长度为n的数列ai，求ai的子序列bi的最长长度，满足bi&amp;bi-1!=0(2&lt;=i&lt;=len)。</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入文件共2行。<br>第一行包括一个整数n。<br>第二行包括n个整数，第i个整数表示ai。</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出文件共一行。<br>包括一个整数，表示子序列bi的最长长度。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>1 2 3</p>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>2</p>
<h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>n&lt;=100000,ai&lt;=2*10^9</p>
<h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p>By Oxer</p>
<p>这道题其实想到了就简单了，是一道根据位计算的DP题。</p>
<p>因为两个&amp;为0的话，必须得所有位置都至少有一个为0</p>
<p>那么这一位，两个数都是1的话，就不会为0了</p>
<p>令f[i]表示第i位为1的最长长度，然后转移就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> n,f[<span class="number">51</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</div><div class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++)</div><div class="line">            <span class="keyword">if</span> (x&amp;(<span class="number">1</span>&lt;&lt;j))</div><div class="line">                t=max(t,f[j]+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++)</div><div class="line">            <span class="keyword">if</span> (x&amp;(<span class="number">1</span>&lt;&lt;j))</div><div class="line">                f[j]=t;</div><div class="line">        ans=max(ans,t);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/组队训练1-回放（转载至cxhscst2-s-blog）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/组队训练1-回放（转载至cxhscst2-s-blog）/" itemprop="url">
                  组队训练1 回放（转载至cxhscst2's blog）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:20:25-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/985728-20170226190607991-812630871.png" alt="logo1"></p>
<p><img src="/985728-20170226191601335-706429505.png" alt="logo2"></p>
<p>第一场组队训练……意料之中的爆炸。</p>
<p>开场先看题，H是斐波那契水题，qw把H切了。</p>
<p>同时czy看I题（排列），cst继续读其他题。</p>
<p>czy尝试交I，PE。</p>
<p>cst发现K是水题。</p>
<p>cst上来敲K，WA。回去检查。</p>
<p>czy继续干I，还是没过。</p>
<p>cst又交了一发K，WA。</p>
<p>czy交了一发I， 终于过了。</p>
<p>cst把K交给了czy之后去看其他题。</p>
<p>与此同时qw开敲C，一发就过。</p>
<p>D题看起来像个递推规律题。</p>
<p>cst猜D结论，WA（事实上这个结论样例都过不去）<br>czy交K，AC（之前cst把题目理解错了）</p>
<p>cst认为E题类似图论经典问题。</p>
<p>cst上来敲E，TLE（算错复杂度）</p>
<p>qw和czy讨论B，发现可做。</p>
<p>czy敲B，WA。</p>
<p>czy和qw发现B完全想错了，重写之后AC。</p>
<p>qw之前一直在想J。J是小数化分数的大模拟。</p>
<p>qw上来刚J，一发就过（太强了！！！）</p>
<p>cst发现A是个计算几何，可做。</p>
<p>cst做A，WA。</p>
<p>czy找到了L的规律。</p>
<p>czy做L，WA。</p>
<p>czy马上意识到0的时候错了，改完之后，AC。</p>
<p>cst再猜一次D，WA。</p>
<p>F也是个计算几何，三个人讨论后决定让qw做。</p>
<p>qw上来做F，WA。</p>
<p>之后就进入了卡题模式。A题和F题都蜜汁WA。</p>
<p>这个时候czy突然时候他会D了，然后过了（ORZ）</p>
<p>这个时候基本放弃了（因为CF马上要开始了）</p>
<p>cst继续尝试E，WA。</p>
<p>cst想了一下，找到了前面TLE的代码，优化了一发，AC！！！</p>
<p>czy和qw应该算正常发挥。</p>
<p>cst完全狗带。。。（只过了一道）</p>
<p>第一次总结：</p>
<p>第一次配合，结果怎么样都正常，做出9道也算马马虎虎（罚时爆炸）</p>
<p>AC率太低了。</p>
<p>前期出题不够快，信心不足。</p>
<p>后期由于体力等原因状态下滑。</p>
<p>cst前期太糟糕了吧，后期也很糟糕。</p>
<p>qw的大模拟能力很强，而且是三个人当中唯一会用Java的。</p>
<p>czy的查错能力非常强，以及做题的信心很足。</p>
<p>以下为qw个人对比赛的总结：</p>
<p>这次的比赛，包括寒假的练习赛，都有个相似的问题：太急躁。</p>
<p>在提交代码之前没有仔细检查导致罚时，</p>
<p>这在真正的比赛中是十分可惜的。</p>
<p>常见的细节错误包括数组开小了、没有初始化、输出多空行、</p>
<p>提交前没有把注释和文件读写删除。</p>
<p>无论如何，在提交代码之前，切记，切记：直接用黑屏幕测试样例，</p>
<p>哪怕只是改了个很小的地方也要重新测试。</p>
<p>还有，切记，读题！读题十分重要！</p>
<p>如果一遍写好后WA了，首先要做的是重新读题，可能题目理解错了，</p>
<p>或者是其中的一个细节没注意。</p>
<p>另外，在前期卡题后要及时换题，复杂度要分析清楚。</p>
<p>当然，今天的比赛毕竟是我们自己建立的，不像真正的比赛有榜，</p>
<p>自然也不知道哪些题是简单题，只能我们自己判断，</p>
<p>在比赛时，根据大家的提交情况，可以判断哪些题容易做。（尽量跟着榜做，但实在想不出也要换题）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/寒假练习赛总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/寒假练习赛总结/" itemprop="url">
                  寒假练习赛总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:16:47-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.18</p>
<p>练习赛第一场。第一场比赛状态很不好，很多人不到3小时就AK，而我因为B、C两题题目读错导致心态变差，最后只A了4道题。可见读题十分重要，如果一下子做不出来，或是WA了，却又有很多人AC，那么切记重新读题，千万不能漏了关键信息。</p>
<p>1.19</p>
<p> Codeforces Round #392 (Div. 2)</p>
<p>练习赛第一场失误，心情不好，因此想好好打一场。比赛时A了4道。A、B、C三题模拟，D题贪心。但不知为什么D题FST了。第二天一看，发现那个数据十分恶心。还好我Rating上升了不少。至此，CF蓝名。</p>
<p>1.20</p>
<p>练习赛第二次。跟着榜做，2个小时A了7题，但是十分可惜，04题没有冲一发暴力。然而，后来04题A的很多。但就是因为觉得复杂度不够而没有尝试，爆炸……</p>
<p>1.21</p>
<p>BestCoder Round #91 </p>
<p>01题很快过初测。其实比赛时就听说01题最后会死掉一大片，但比赛时并不知道叉点是什么。比赛结束后果然被hack，后来看了一下别人的代码终于知道自己的做法很有问题。</p>
<p>02题是差分序列，然而之前这类题并没有做过，后来写了个DP，WA了很久……</p>
<p>这场比赛爆零，血崩了……</p>
<p>1.23</p>
<p>第三场比赛</p>
<p>这场比赛较简单,不到3小时AK，唯一可惜的是有一题说了不能用除法，结果还是用了，WA了好几发。主要是因为比赛时总觉得用除法转化成小数和直接扩大倍数整数计算没有任何区别，后来测了很多数据才发现确实存在精度。这题WA了九发，导致罚时很多。切记，一定要仔细读题，按题目要求做，不能遗漏任何一个条件！</p>
<p>1.25</p>
<p>第四场比赛</p>
<p>相比之前的比赛，难度上了一个层次，是很有区分度的一场比赛。先做06，一开始读错题，WA了4发才AC，可惜了，又是好多罚时。接着02，是水题，直接AC。但因为之前在看别的题，花了较长时间。再做08题，只要稍做优化即可，也一次AC。接着01题，是个组合数处理，想了一段时间，WA了2发后AC。简单题没有了。接着只要有人AC的题都读了一下题目，05题是一道数学题，但十分复杂，涉及椭圆积分知识，查了很多资料后推公式才AC。03题想到了用堆的贪心，但算了下复杂度还是不够。04题看似较复杂，后来想了一下，数据才100，直接排序再LIS复杂度也够，AC。奇怪的是，07题，一了道BFS的题居然没人做，因为还有时间，开始写BFS，WA一发后AC。第四场就这样结束了。因此如果实在想不出做法有时也可以不跟榜做，但需要谨慎，避免浪费太长时间！</p>
<p>1.31</p>
<p>Codeforces Round #394 (Div. 2)</p>
<p>这次比赛网络很差，一直无法提交，包括比赛时排名榜也很难加载出来。本身个人状态也不是很好，A题B题也WA了几发才A，又是因为一开始题目读错。而且A题还被hack。C题想复杂，写了170多行代码，虽然过了初测，但是FST了。幸好这次unrated，不然rating要掉很多了（排名2000多了）。赛后发现，D、E两题也很简单，D题只是一个简单的贪心，E题DFS+乱搞即可。</p>
<p>2.2</p>
<p>Codeforces Round #395 (Div. 2)</p>
<p>很快完成2道签到题，之后完全挂机。哎，好不容易蓝名的，rating又掉了。第二天一看，C、D两题做法十分巧妙，尤其是C核心代码只有4行，只是当时没想到啊！</p>
<p>2.3</p>
<p>练习赛第5次。这场还是比较简单，虽然有几题稍微卡了一下，但3个多小时AK。这回又考到差分序列，一开始其实并未想到，后来发现跟BC#91的B题差不多。这题又很多罚时了。还有最后一题，看起来很复杂，但想到却十分简单。</p>
<p>2.6</p>
<p>练习赛第6次。三个小时不到AK，题目总体不难，就2题稍微卡了一下，一题贪心，一题二分答案+二分图匹配（这题一开始题目又读错了，以为是任意2个组合，所以一开始一直没有思路……）</p>
<p>2.8</p>
<p>练习赛第7次。居然是DP专场！有三道题都考了DP，一题水背包，一题有点像最大子段和，一题就是同一阶段计算2个状态的最小值。但A题居然卡了读入！当时还不会fread读入挂。首先看JAVA时限给了2s，交了1发JAVA，没想到还是TLE。原来是JAVA也需要加读入挂。然后C++重新写，用了getchar读入挂，还是TLE。在比赛时这题始终没有AC，赛后交fread读入挂，AC。还有就是H题，用BFS写，WA了一个多小时，原来是一个细节始终没有发现，第一次走到的并不一定是最优解！其实直接暴力+存下状态即可。</p>
<p>2.10</p>
<p>练习赛第8次。题目总体比较简单。就是2题稍微卡了一下。1题其实是合并果子，但一开始没有发现，最后用区间DP A了（其实我的做法很有问题，还好数据比较弱），正确的做法是排序+2个队列存最小值和次小值或直接用优先队列。1题是并查集，但题目表达有问题，这题一开始始终没有人AC，因此我一开始也不敢做。后来看到有人AC，在集训队群里提出了这道题表述的问题，事实上，这道题是简单题。当时比赛还剩下1个小时，赶紧写并查集，WA了2发后AC。</p>
<p>2.15</p>
<p>练习赛第10次，题目不像之前那样简单，出现了数学题和DP题。有2道题较难，3小时后挂机。赛后才知道一道题原来是可以找规律的，让我想起之前的一类小学奥数题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/ACM算法模板集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/ACM算法模板集/" itemprop="url">
                  ACM算法模板集
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:15:37-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Contents</p>
<p>一. 常用函数与STL</p>
<p>二. 重要公式与定理</p>
<ol>
<li><p>Fibonacci Number</p>
</li>
<li><p>Lucas Number</p>
</li>
<li><p>Catalan Number</p>
</li>
<li><p>Stirling Number(Second Kind)</p>
</li>
<li><p>Bell Number</p>
</li>
<li><p>Stirling’s Approximation</p>
</li>
<li><p>Sum of Reciprocal Approximation</p>
</li>
<li><p>Young Tableau</p>
</li>
<li><p>整数划分</p>
</li>
<li><p>错排公式</p>
</li>
<li><p>三角形内切圆半径公式</p>
</li>
<li><p>三角形外接圆半径公式</p>
</li>
<li><p>圆內接四边形面积公式</p>
</li>
<li><p>基础数论公式</p>
</li>
</ol>
<p>三. 大数模板</p>
<p>四. 数论算法</p>
<ol>
<li><p>Greatest Common Divisor最大公约数</p>
</li>
<li><p>Prime素数判断</p>
</li>
<li><p>Sieve Prime素数筛法</p>
</li>
<li><p>Module Inverse模逆元</p>
</li>
<li><p>Extended Euclid扩展欧几里德算法</p>
</li>
<li><p>Modular Linear Equation模线性方程(同余方程)</p>
</li>
<li><p>Chinese Remainder Theorem中国余数定理</p>
</li>
</ol>
<p>五. 图论算法</p>
<ol>
<li><p>最小生成树(Kruscal算法)</p>
</li>
<li><p>最小生成树(Prim算法)</p>
</li>
<li><p>单源最短路径(Bellman-ford算法)</p>
</li>
<li><p>单源最短路径(Dijkstra算法)</p>
</li>
<li><p>全源最短路径(Folyd算法)</p>
</li>
<li><p>拓扑排序</p>
</li>
<li><p>网络预流和最大流</p>
</li>
<li><p>网络最小费用最大流</p>
</li>
<li><p>网络最大流(高度标号预流推进)</p>
</li>
<li><p>最大团</p>
</li>
<li><p>最大二分图匹配(匈牙利算法)</p>
</li>
</ol>
<p>六. 几何算法</p>
<ol>
<li><p>几何模板</p>
</li>
<li><p>球面上两点最短距离</p>
</li>
<li><p>三点求圆心坐标</p>
</li>
</ol>
<p>七. 专题讨论</p>
<ol>
<li><p>树状数组</p>
</li>
<li><p>字典树</p>
</li>
<li><p>后缀树</p>
</li>
<li><p>线段树</p>
</li>
<li><p>并查集</p>
</li>
<li><p>二叉堆</p>
</li>
<li><p>逆序数(归并排序)</p>
</li>
<li><p>树状DP</p>
</li>
<li><p>欧拉路</p>
</li>
<li><p>八数码</p>
</li>
<li><p>高斯消元法</p>
</li>
<li><p>字符串匹配(KMP算法)</p>
</li>
<li><p>全排列,全组合</p>
</li>
</ol>
<p>第一章常用函数和STL</p>
<p>一.    常用函数</p>
<p>#include <stdio.h><br>int getchar( void );               //读取一个字符, 一般用来去掉无用字符<br>char <em>gets( char </em>str );          //读取一行字符串</stdio.h></p>
<p>#include <stdlib.h><br>void <em> malloc( size_t size );     //动态内存分配, 开辟大小为 size 的空间<br>void qsort( void </em>buf, size_t num, size_t size, int (<em>compare)(const void </em>, const void *) );                    //快速排序<br>Sample:</stdlib.h></p>
<p>int compare_ints( const void<em> a, const void</em> b )<br>{<br>int<em> arg1 = (int</em>) a;        int<em> arg2 = (int</em>) b;<br>if( <em>arg1 &lt; </em>arg2 ) return -1;<br>else if( <em>arg1 == </em>arg2 ) return 0;<br>else return 1;<br>}<br>int array[] = { -2, 99, 0, -743, 2, 3, 4 };     int array_size = 7;<br>qsort( array, array_size, sizeof(int), compare_ints ); </p>
<p>#include <math.h><br>//求反正弦, arg∈[-1, 1], 返回值∈[-pi/2, +pi/2]<br>double asin( double arg );<br>//求正弦, arg为弧度, 弧度=角度*Pi/180.0, 返回值∈[-1, 1]<br>double sin( double arg );<br>//求e的arg次方<br>double exp( double arg );<br>//求num的对数, 基数为e<br>double log( double num );<br>//求num的根<br>double sqrt( double num );<br>//求base的exp次方<br>double pow( double base, double exp );</math.h></p>
<p>#include <string.h><br>//初始化内存, 常用来初始化数组<br>void<em> memset( void</em> buffer, int ch, size_t count );<br>memset( the_array, 0, sizeof(the_array) );<br>//printf是它的变形, 常用来将数据格式化为字符串<br>int sprintf( char <em>buffer, const char </em>format, … );<br>sprintf(s, “%d%d”, 123, 4567); //s=”1234567”<br>//scanf是它的变形, 常用来从字符串中提取数据<br>int sscanf( const char <em>buffer, const char </em>format, … );</string.h></p>
<p>Sample:<br>char result[100]=”24 hello”, str[100];          int num;<br>sprintf( result, “%d %s”, num,str );//num=24;str=”hello” ;<br>//字符串比较, 返回值<0代表str1<str2, =0代表str1="str2,">0代表str1&gt;str2<br>int strcmp( const char <em>str1, const char </em>str2 );</0代表str1<str2,></p>
<p>二.    常用STL</p>
<p>[标准container概要]</p>
<p>vector<t>                         大小可变的向量, 类似数组的用法, 容易实现删除</t></p>
<p>list<t>                              双向链表</t></p>
<p>queue<t>                         队列, empty(), front(), pop(), push()</t></p>
<p>stack<t>                          栈, empty(), top(), pop(), push()</t></p>
<p>priority_queue<t>          优先队列, empty(), top(), pop(), push()</t></p>
<p>set<t>                              集合</t></p>
<p>map<key,val>                   关联数组, 常用来作hash映射</key,val></p>
<p>[标准algorithm摘录]</p>
<p>for_each()                          对每一个元素都唤起（调用）一个函数</p>
<p>find()                     查找第一个能与引数匹配的元素</p>
<p>replace()                   用新的值替换元素, O(N)</p>
<p>copy()                          复制（拷贝）元素, O(N)</p>
<p>remove()                            移除元素</p>
<p>reverse()                            倒置元素</p>
<p>sort()                     排序, O(N log(N))</p>
<p>partial_sort()                部分排序</p>
<p>binary_search()                 二分查找</p>
<p>merge()                  合并有序的序列, O(N)</p>
<p>[C++ String摘录]</p>
<p>copy()                              从别的字符串拷贝</p>
<p>empty()                            判断字符串是否为空</p>
<p>erase()                              从字符串移除元素</p>
<p>find()                                 查找元素</p>
<p>insert()                              插入元素</p>
<p>length()                              字符串长度</p>
<p>replace()                            替换元素</p>
<p>substr()                            取子字符串</p>
<p>swap()                               交换字符串</p>
<p>第二章重要公式与定理</p>
<p>Fibonacci Number<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610 …</p>
<p>Formula:</p>
<ol>
<li>Lucas Number<br>1, 3, 4, 7, 11, 18, 29, 47, 76, 123…</li>
</ol>
<p>Formula:</p>
<ol>
<li>Catalan Number<br>1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012…</li>
</ol>
<p>Formula:</p>
<p>Application:</p>
<p>1)    将 n + 2 边形沿弦切割成 n个三角形的不同切割数</p>
<p>Sample:</p>
<p>n = 2;     </p>
<p>n = 3;     </p>
<p>2)    n + 1个数相乘, 给每两个元素加上括号的不同方法数</p>
<p>Sample:</p>
<p>n = 2;      (1 (2 3)),       ((1 2) 3)</p>
<p>n = 3;      (1 (2 (3 4))),  (1 ((2 3) 4)) ,  ((1 2) (3 4)),  ((1 (2 3)) 4),  (((1 2) 3) 4)</p>
<p>3)    n 个节点的不同形状的二叉树数(严《数据结构》P.155)</p>
<p>4)    从n * n 方格的左上角移动到右下角不升路径数</p>
<p>Sample:</p>
<p>n = 2;     </p>
<p>n = 3;     </p>
<ol>
<li>Stirling Number(Second Kind)<br>S(n, m)表示含n个元素的集合划分为m个集合的情况数</li>
</ol>
<p>或者是n个有标号的球放到m 个无标号的盒子中, 要求无一为空, 其不同的方案数</p>
<p>Formula:</p>
<p>Special Cases:</p>
<ol>
<li>Bell Number<br>n 个元素集合所有的划分数</li>
</ol>
<p>Formula:</p>
<ol>
<li>Stirling’s Approximation</li>
</ol>
<ol>
<li>Sum of Reciprocal Approximation<br>EulerGamma = 0.57721566490153286060651209;</li>
</ol>
<ol>
<li>Young Tableau<br>Young Tableau(杨式图表)是一个矩阵, 它满足条件:</li>
</ol>
<p>如果格子[i, j]没有元素, 则[i+1, j]也一定没有元素</p>
<p>如果格子[i, j]有元素a[i, j],则[i+1, j]要么没有元素, 要么a[i+1, j] &gt; a[i, j]</p>
<p>Y[n]代表n个数所组成的杨式图表的个数</p>
<p>Formula:</p>
<p>Sample:</p>
<p>n = 3;    </p>
<ol>
<li>整数划分<br>将整数n分成k份, 且每份不能为空, 任意两种分法不能相同</li>
</ol>
<p>1) 不考虑顺序</p>
<p>for(int p=1; p&lt;=n ;p++)<br>     for(int i=p; i&lt;=n ;i++)<br>          for(int j=k; j&gt;=1 ;j–)<br>               dp[i][j] += dp[i-p][j-1];<br>cout&lt;&lt; dp[n][k] &lt;&lt;endl;</p>
<p>2) 考虑顺序</p>
<p>dp[i][j] = dp[i-k][j-1]; (k=1..i)</p>
<p>3) 若分解出来的每个数均有一个上限m</p>
<p>dp[i][j] = dp[i-k][ j-1]; (k=1..m)</p>
<ol>
<li>错排公式</li>
</ol>
<ol>
<li>三角形内切圆半径公式</li>
</ol>
<ol>
<li>三角形外接圆半径公式</li>
</ol>
<ol>
<li>圆內接四边形面积公式</li>
</ol>
<ol>
<li>基础数论公式<br>1) 模取幂</li>
</ol>
<p>2) n的约数的个数</p>
<p>若n满足, 则n的约数的个数为</p>
<p>第三章大数模板</p>
<p>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></p>
<ul>
<li><p>Function Name :        BigNumber</p>
</li>
<li><p>Description :                     BigNumber’s HPC</p>
</li>
<li>Author :                            HuangWei</li>
<li>Last Edited :               07.4.11<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include <iostream><br>#include <string><br>#include <sstream><br>#include <memory><br>#include <algorithm></algorithm></memory></sstream></string></iostream></li>
</ul>
<p>#define BASE     1000      // 基数</p>
<p>#define DIG        1100      // 存储<br>using namespace std;</p>
<p>class BigNumber<br>{<br>private:<br>     int data[DIG];                     // 数据区<br>     int len;                          // 记录长度<br>public:<br>     BigNumber()     {len=1;memset(data,0,sizeof(data));data[0]=1;}<br>     BigNumber(int);          // 输入默认十进制<br>     BigNumber(char<em>);<br>     BigNumber(const BigNumber &amp;);<br>     // 类型转换<br>     BigNumber &amp; Num_BNum(int); //把一个整数转换成BigNumber型的<br>     BigNumber &amp; Str_BNum(char</em>); //把一个字符串类型的转换成BigNumber型的<br>     int Int();<br>     string Str();<br>     // HPC<br>     BigNumber &amp; Add(const BigNumber &amp;);<br>     BigNumber &amp; Sub(const BigNumber &amp;);<br>     BigNumber &amp; Mul(const BigNumber &amp;);<br>     BigNumber &amp; Div(int);<br>     BigNumber &amp; Mod(int);<br>     BigNumber &amp; operator=(const BigNumber &amp;);<br>     int Bigger(const BigNumber &amp;) const;</p>
<pre><code>BigNumber operator + (const BigNumber &amp;);
BigNumber operator - (const BigNumber &amp;);
BigNumber operator * (const BigNumber &amp;);
BigNumber operator / (int);
BigNumber operator % (int);

BigNumber &amp; operator += (const BigNumber &amp;);
BigNumber &amp; operator -= (const BigNumber &amp;);
BigNumber &amp; operator *= (const BigNumber &amp;);
BigNumber &amp; operator /= (int);
BigNumber &amp; operator %= (int);
</code></pre><p>};</p>
<p>BigNumber &amp; BigNumber::Num_BNum(int b)<br>{<br>     len=1;     memset(data,0,sizeof(data));<br>     data[0] = 1;<br>     if(b &lt; 0) {<br>          b = -b;<br>          data[0] = -1;<br>     }<br>     while(b &gt; 0) {<br>          data[ len++ ] = b % BASE;<br>          b /= BASE;<br>     }<br>     return *this;<br>}</p>
<p>BigNumber &amp; BigNumber::Str_BNum(char<em> sb)<br>{<br>     int t=0, d=1, b=0, slen=strlen(sb), i;<br>     len=1;     memset(data,0,sizeof(data));<br>     data[0] = 1;<br>     if(sb[0] == ‘-‘)     data[0] = -1, b=1;<br>     for(i=slen-1; i&gt;=b ;i–) {<br>          while(t &gt;= BASE || d &gt; BASE) {<br>               data[ len++ ] = t % BASE;<br>               t /= BASE;<br>               d = 10;<br>          }<br>          t += (sb[i]-‘0’) </em> d;<br>          d <em>= 10;<br>     }<br>     while(t &gt; 0) {<br>          data[ len++ ] = t % BASE;<br>          t /= BASE;<br>     }<br>     return </em>this;<br>}</p>
<p>int BigNumber::Int()<br>{<br>     istringstream sin;<br>     int v;<br>     sin.str( this-&gt;Str() );<br>     sin &gt;&gt; v;<br>     return v;<br>}  //这个函数的用法还是第一次看到，没看懂</p>
<p>string BigNumber::Str()<br>{<br>     int i,base_len=0;<br>     ostringstream sout;<br>     if(len == 1) {<br>          sout &lt;&lt; ‘0’;<br>          //sout &lt;&lt; endl;<br>          return sout.str();<br>     }<br>     if(data[0] &lt; 0)     sout &lt;&lt; “-“;<br>     sout &lt;&lt; data[len-1];<br>     i = BASE;<br>     while(i &gt; 1) {<br>          base_len++;<br>          i /= 10;<br>     }<br>     for(i=len-2; i&gt;0 ;i–) {<br>          sout.width(base_len);<br>          sout.fill(‘0’);<br>          sout &lt;&lt; data[i];<br>     }<br>     //sout &lt;&lt; endl;<br>     return sout.str();<br>} //这个函数也没有看懂</p>
<p>BigNumber::BigNumber(int b)<br>{this-&gt;Num_BNum(b);}</p>
<p>BigNumber::BigNumber(char* sb)<br>{this-&gt;Str_BNum(sb);}<br>// -1 a<b, 0="" 1="" a="=b,">b<br>BigNumber::BigNumber(const BigNumber &amp; b)<br>{len = b.len;     memcpy(data,b.data,sizeof(data));}</b,></p>
<p>int BigNumber::Bigger(const BigNumber &amp; b) const<br>{<br>     int i,flag;<br>     if(data[0] ==1 &amp;&amp; b.data[0] ==1)          flag = 1;<br>     else if(data[0] ==1 &amp;&amp; b.data[0] ==-1)     return 1;<br>     else if(data[0] ==-1 &amp;&amp; b.data[0] ==1)     return -1;<br>     else                                             flag = -1;</p>
<pre><code>if(len &gt; b.len)     return flag;
else if(len == b.len) {
     for(i=len-1; i&gt;0 ;i--)
          if(data[i] &gt; b.data[i])     return flag;
}
if(i == 0)     return 0;
return -flag;
</code></pre><p>} //比较函数</p>
<p>BigNumber &amp; BigNumber::Add(const BigNumber &amp; b)<br>{<br>     int i;<br>     if(data[0] <em> b.data[0] != 1) {<br>          data[0] = -data[0];<br>          Sub(b);<br>          data[0] = -data[0];<br>          return </em>this;<br>     }<br>     len= len &gt; b.len ? len : b.len;<br>     for(i=1; i<len ;i++)="" {="" data[i]="" +="b.data[i];" if(data[i]="">= BASE) {<br>               data[i+1]++;<br>               data[i] -= BASE;<br>          }<br>     }<br>     if(data[i] &gt; 0)     len = i+1;<br>     return *this;<br>} //加上b这个大数</len></p>
<p>BigNumber &amp; BigNumber::Sub(const BigNumber &amp; b)<br>{<br>     int i;<br>     if(data[0] <em> b.data[0] != 1) {<br>          data[0] = -data[0];<br>          Add(b);<br>          data[0] = -data[0];<br>          return </em>this;<br>     }<br>     len= len &gt; b.len ? len : b.len;<br>     for(i=1; i&lt;len ;i++) {<br>          data[i] -= b.data[i];<br>          if(data[i] &lt; 0) {<br>               data[i+1]–;<br>               data[i] += BASE;<br>          }<br>     }<br>     if(data[len] &lt; 0) {<br>          for(i=0; i&lt;=len ;i++)<br>               data[i] = -data[i];<br>          for(i=1; i&lt;len ;i++)<br>               if(data[i] &lt; 0) {<br>                    data[i+1]–;<br>                    data[i] += BASE;<br>               }<br>     }<br>     while(data[len-1] == 0)     len–;<br>     return *this;<br>}</p>
<p>BigNumber &amp; BigNumber::Mul(const BigNumber &amp; b)<br>{<br>     BigNumber bt;<br>     int i,j,up;<br>     int temp,temp1;</p>
<pre><code>bt.data[0] = data[0] * b.data[0];
for(i=1; i&lt;len ;i++) {
     up = 0;
     for(j=1; j&lt;b.len ;j++) {
          temp = data[i] * b.data[j] + bt.data[i+j-1] + up;
          if(temp &gt;= BASE) {
               temp1 = temp % BASE;
               up = temp / BASE;
               bt.data[i+j-1] = temp1;
          }
          else {
               up = 0;
               bt.data[i+j-1] = temp;
          }
     }
     if(up != 0)     bt.data[i+j-1] = up;
}
bt.len = i+j;
while(bt.data[bt.len-1] == 0) bt.len--;
*this=bt;
return *this;
</code></pre><p>}</p>
<p>BigNumber &amp; BigNumber::Div(int b)<br>{<br>     BigNumber bt;<br>     int i,down = 0;</p>
<pre><code>if(b &lt; 0)     bt.data[0] = -data[0] , b = -b;
else          bt.data[0] = data[0];
for(i=len-1; i&gt;=1 ;i--) {
     bt.data[i] = (data[i] + down * BASE) / b;
     down = data[i] + down * BASE - bt.data[i] * b;
}
bt.len = len;
while(bt.data[bt.len-1] == 0)     bt.len--;
*this=bt;
return *this;
</code></pre><p>}</p>
<p>BigNumber &amp; BigNumber::Mod(int b)<br>{<br>     int temp = 0, up = 0, i;<br>     for(i=len-1; i&gt;=1 ;i–) {<br>          temp = data[i];<br>          temp += up <em> BASE;<br>          up = temp % b;<br>     }<br>     if(data[0] &lt; 0)     up = -up;
     </em>this = up;<br>     return *this;<br>}</p>
<p>BigNumber &amp; BigNumber::operator = (const BigNumber &amp; b)<br>{len = b.len;     memcpy(data,b.data,sizeof(data));     return *this;}</p>
<p>BigNumber BigNumber::operator + (const BigNumber &amp; b)<br>{BigNumber bt=*this;     return bt.Add(b);}</p>
<p>BigNumber BigNumber::operator - (const BigNumber &amp; b)<br>{BigNumber bt=*this;     return bt.Sub(b);}</p>
<p>BigNumber BigNumber::operator <em> (const BigNumber &amp; b)<br>{BigNumber bt=</em>this;     return bt.Mul(b);}</p>
<p>BigNumber BigNumber::operator / (int b)<br>{BigNumber bt=*this;     return bt.Div(b);}</p>
<p>BigNumber BigNumber::operator % (int b)<br>{BigNumber bt=*this;     return bt.Mod(b);}</p>
<p>BigNumber &amp; BigNumber::operator += (const BigNumber &amp; b)<br>{return this-&gt;Add(b);}</p>
<p>BigNumber &amp; BigNumber::operator -= (const BigNumber &amp; b)<br>{return this-&gt;Sub(b);}</p>
<p>BigNumber &amp; BigNumber::operator *= (const BigNumber &amp; b)<br>{return this-&gt;Mul(b);}</p>
<p>BigNumber &amp; BigNumber::operator /= (int b)<br>{return this-&gt;Div(b);}</p>
<p>BigNumber &amp; BigNumber::operator %= (int b)<br>{return this-&gt;Mod(b);}</p>
<p>第四章数论算法</p>
<ol>
<li><p>Greatest Common Divisor最大公约数<br>int GCD(int x, int y)<br>{<br>int t;<br>while(y &gt; 0) {<br>t = x % y;<br>x = y;<br>y = t;<br>}<br>return x;<br>}</p>
</li>
<li><p>Prime素数判断<br>bool is_prime(int u)<br>{<br>if(u == 0 || u == 1)       return false;<br>if(u == 2)                     return true;<br>if(u%2 == 0)               return false;<br>for(int i=3; i &lt;= sqrt(u) ;i+=2)<br>if(u%i==0)     return false;<br>return true;<br>}</p>
</li>
<li><p>Sieve Prime素数筛法<br>const int M = 1000; // M : size<br>bool mark[M]; // true : prime number<br>void sieve_prime()<br>{<br>memset(mark, true, sizeof(mark));<br>mark[0] = mark[1] = false;<br>for(int i=2; i &lt;= sqrt(M) ;i++) {<br>if(mark[i]) {</p>
<pre><code>for(int j=i*i; j &lt; M ;j+=i)
     mark[j] = false;
</code></pre><p>}<br>}<br>}</p>
</li>
</ol>
<ol>
<li><p>Module Inverse模逆元<br>// ax ≡ 1 (mod n)<br>int Inv(int a, int n)<br>{<br>int d, x, y;<br>d = extended_euclid(a, n, x, y);<br>if(d == 1)       return (x%n + n) % n;<br>else                return -1; // no solution<br>}</p>
</li>
<li><p>Extended Euclid扩展欧几里德算法<br>//如果GCD(a,b) = d, 则存在x, y, 使d = ax + by</p>
</li>
</ol>
<p>// extended_euclid(a, b) = ax + by<br>int extended_euclid(int a, int b, int &amp;x, int &amp;y)<br>{<br>     int d;<br>     if(b == 0) {x = 1;     y = 0;     return a;}<br>     d = extended_euclid(b, a % b, y, x);<br>     y -= a / b * x;<br>     return d;<br>}</p>
<ol>
<li>Modular Linear Equation模线性方程(同余方程)<br>//如果GCD(a, b)不能整除c, 则ax + by = c 没有整数解</li>
</ol>
<p>// ax ≡ b (mod n) n &gt; 0</p>
<p>//上式等价于二元一次方程ax – ny = b<br>void modular_linear_equation(int a, int b, int n)<br>{<br>     int d, x, y, x0;<br>     d = extended_euclid(a, n, x, y);<br>     if( b%d == 0) {<br>          x0 = ( x<em>(b/d) ) % n; // x0 : basic solution<br>          int ans = n;<br>          for(int i=0; i &lt; d ;i++) {<br>               ans = ( x0 + i</em>(n/d) ) % n;<br>               cout &lt;&lt; ans &lt;&lt; endl;<br>          }<br>     }<br>     else     cout &lt;&lt; “no solution” &lt;&lt; endl;<br>}</p>
<ol>
<li>Chinese Remainder Theorem中国余数定理<br>// x ≡ b[i] (mod w[i]), i∈[1, len-1]<br>// 前提条件w[i] &gt; 0, 且w[]中任意两个数互质<br>int chinese_remainder(int b[], int w[], int len)<br>{<br>int i, d, x, y, m, n;<br>x = 0;     n = 1;<br>for(i=0; i &lt; len ;i++)     n <em>= w[i];<br>for(i=0; i &lt; len ;i++) {<br>m = n / w[i] ;<br>d = extended_euclid(w[i], m, x, y);<br>x = (x + y</em>m*b[i]) % n;<br>}<br>return (n + x%n) % n;<br>}</li>
</ol>
<p>第五章图论算法</p>
<ol>
<li>最小生成树(Kruscal算法)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        最小生成树(Kruscal算法)</li>
<li>Description :              ZJU 1203 Swordfish O(E<em>LogE)<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><em>* </em></strong></em>/<br>#include <iostream><br>#include <algorithm><br>#include <cstdio><br>#include <cmath><br>using namespace std;<br>struct struct_edges<br>{<br>int bv,tv; //bv 起点  tv 终点<br>double w; //权值<br>};<br>struct_edges edges[10100]; //边集<br>struct struct_a<br>{<br>double x;<br>double y;<br>};<br>struct_a arr_xy[101];<br>int point[101],n,e;  //n 顶点数, e 边数(注意是无向网络)<br>double sum;</cmath></cstdio></algorithm></iostream></li>
</ul>
<p>int kruscal_f1(int point[], int v)<br>{<br>     int i = v;<br>     while(point[i] &gt; 0)     i = point[i];<br>     return i;<br>}</p>
<p>bool UDlesser(struct_edges a, struct_edges b)<br>{return a.w &lt; b.w;}</p>
<p>void kruscal() //只需要准备好n，e，递增的边集edges[]即可使用<br>{<br>     int v1,v2,i,j;<br>     for(i=0; i&lt;n ;i++)     point[i]=0;<br>     i = j = 0;<br>     while(j&lt;n-1 &amp;&amp; i&lt;e) {<br>          v1 = kruscal_f1(point, edges[i].bv);<br>          v2 = kruscal_f1(point, edges[i].tv);<br>          if(v1 != v2) {<br>               sum += edges[i].w; //注意sum初始为0<br>               point[v1]=v2;<br>               j++;<br>          }<br>          i++;<br>     }<br>}</p>
<p>int main()<br>{<br>     int k,i,j;<br>     cin&gt;&gt;n;<br>     k=0;<br>     while(n != 0) {<br>          sum=0;<br>          k++;<br>          for(i=0; i<n ;i++)="" cin="">&gt;arr_xy[i].x&gt;&gt;arr_xy[i].y;<br>          e=0;<br>          for(i=0; i&lt;n ;i++) //从0开始计数<br>               for(j=i+1; j&lt;n ;j++) //注意是无向网络<br>               {<br>                    if(i == j) continue;<br>                    edges[e].bv=i;<br>                    edges[e].tv=j;<br>                    edges[e].w=sqrt((arr_xy[i].x-arr_xy[j].x)<em>(arr_xy[i].x-arr_xy[j].x)+(arr_xy[i].y-arr_xy[j].y)</em>(arr_xy[i].y-arr_xy[j].y));<br>                    e++;<br>               }<br>               sort(edges,edges+e,UDlesser);  //得到一个递增的边集，注意是从0开始计数<br>               kruscal();</n></p>
<pre><code>          printf(&quot;Case #%d:\n&quot;,k);  //cout&lt;&lt;&quot;Case #&quot;&lt;&lt;k&lt;&lt;&quot;:&quot;&lt;&lt;endl;
          printf(&quot;The minimal distance is: %.2f\n&quot;,sum);  //输出sum
          cin&gt;&gt;n;
          if(n != 0) printf(&quot;\n&quot;);
}
</code></pre><p>}</p>
<ol>
<li>最小生成树(Prim算法)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        最小生成树(Prim算法)</li>
<li>Description :              ZJU 1203 Swordfish O(N^2)<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include <iostream><br>#include <cmath><br>#include <cstdio><br>using namespace std;<br>double sum, arr_list[101][101], min;<br>int i, j, k=0, n;</cstdio></cmath></iostream></li>
</ul>
<p>struct struct_a<br>{<br>     float x;<br>     float y;<br>};<br>struct_a arr_xy[101];<br>struct struct_b<br>{<br>     int point;<br>     float lowcost;<br>};<br>struct_b closedge[101];</p>
<p>void prim(int n)   //prim  需要准备：n顶点数 arr_list[][]顶点的邻接矩阵也是从0开始计数<br>{<br>     int i,j,k;<br>     k=0;<br>     for(j=0; j<n 0="" ;j++)="" {="" if(j="" !="k)" closedge[j].point="k;" closedge[j].lowcost="arr_list[k][j];" }="" closedge[k].lowcost="0;" for(i="0;" i<n="" ;i++)="" min="10000;" for(j="0;" j<n="" if="" (closedge[j].lowcost="" &&="" <="" min)="" k="j;" sum="" +="closedge[k].lowcost;" 不要改成sum+="min;" sum即为所求值="" if(arr_list[k][j]="" closedge[j].lowcost)="" *="" arr_list[][]="Wij" 如果vi,="" vj有边="" 如果i="j" 无限大="" 如果没有边="" int="" main()="" cin="">&gt;n;<br>     while(n != 0) {<br>          sum=0;<br>          k++;<br>          for(i=0; i<n ;i++)="" cin="">&gt;arr_xy[i].x&gt;&gt;arr_xy[i].y;<br>          for(i=0; i&lt;n ;i++)<br>               for(j=0; j&lt;n ;j++) //得到邻接矩阵arr_list[][]<br>                    arr_list[i][j]=arr_list[j][i]=sqrt((arr_xy[i].x-arr_xy[j].x)<em>(arr_xy[i].x-arr_xy[j].x)+(arr_xy[i].y-arr_xy[j].y)</em>(arr_xy[i].y-arr_xy[j].y));<br>          prim(n);</n></n></p>
<pre><code>     cout&lt;&lt;&quot;Case #&quot;&lt;&lt;k&lt;&lt;&quot;:&quot;&lt;&lt;endl;
     printf(&quot;The minimal distance is: %.2f\n&quot;,sum);
     cin&gt;&gt;n;
     if(n!=0)     printf(&quot;\n&quot;);
}
</code></pre><p>}</p>
<ol>
<li>单源最短路径(Bellman-ford算法)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        单源最短路径(Bellman-ford算法)</li>
<li>Description :              可允许有负权<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include <stdio.h><br>#define MAX 100<br>#define MAXNUM 1000000</stdio.h></li>
</ul>
<p>typedef struct graphnode<br>{<br>     int vexnum; //顶点数<br>     int arcnum; //边数<br>     int gra[MAX][MAX]; //图<br>}Graph;<br>Graph *G;<br>//arc数组中存储的第一个顶点到其他顶点的最短路径<br>//结果存在dis数组中<br>int dis[MAX];<br>int arc[MAX][MAX];</p>
<p>void bellman(Graph *G)<br>{<br>     int i,j;<br>     bool sign;<br>     for(i=0; i &lt; G-&gt;vexnum ;i++)     dis[i]=MAXNUM;<br>     dis[1] = 0;<br>     sign = true;<br>     for(i=1; i &lt; G-&gt;vexnum ;i++) {<br>          sign = false;<br>          for(j=0; j &lt; G-&gt;arcnum ;j++) {<br>               if(dis[ arc[j][0] ] &lt; MAXNUM<br>                    &amp;&amp; dis[ arc[j][1] ] &gt; dis[ arc[j][0] ] + G-&gt;gra[ arc[j][0] ][ arc[j][1] ])<br>               {<br>                    dis[ arc[j][1] ]=dis[ arc[j][0] ] + G-&gt;gra[ arc[j][0] ][ arc[j][1] ];<br>                    sign = true;<br>               }<br>          }<br>     }<br>     return;<br>}</p>
<ol>
<li>单源最短路径(Dijkstra算法)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        单源最短路径 (Dijkstra算法)</li>
<li>Description :              贪心, O(N^2), 不能有负权<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>int matrix[200][200],n;          //matrix[][], 30000表示无限大,即无边.否则为有边,其值为边的权值<br>void Dijkstra(int x,int y)     //起点Vx 终点Vy<br>{<br>int i,j,k,path[40000],mark[40000];<br>int min,dist[40000];<br>for(i=1;i&lt;=n;i++) {<pre><code>mark[i] = 0;
dist[i] = matrix[x][i];
path[i] = x;
</code></pre>}<br>mark[x] = 1;<br>do {<pre><code>min=30000;
k=0;
for(i=1;i&lt;=n;i++)
     if(mark[i]==0 &amp;&amp; dist[i]&lt;min) {
          min = dist[i];
          k = i;
     }
if(k) {
     mark[k] = 1;
     for(i=1;i&lt;=n;i++)
          if(matrix[k][i]&lt;30000 &amp;&amp; min+matrix[k][i]&lt;dist[i]) {
               dist[i] = min + matrix[k][i];
               path[i] = k;
          }
}
</code></pre>}while(k);<br>cout&lt;&lt;dist[y]&lt;&lt;endl;     //dist[y] 的值就是从Vx 到 Vy 的最短路径值<br>//如果希望得到路径，加入如下代码：<br>do {<pre><code>cout&lt;&lt;k&lt;&lt;&quot;&lt;--&quot;;
k = path[k];
</code></pre>}while(k!=x);<br>cout&lt;&lt;x&lt;&lt;endl;<br>}</li>
</ul>
<ol>
<li>全源最短路径(Folyd算法)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        全源最短路径(Folyd算法)</li>
<li>Description :                     DP, O(N^3)<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>//初始化<br>//min_graph[i][j]=graph[i][j];<br>//path[i][j]=j;<br>void Floyd()<br>{<br>int i,j,k;<br>for(k=0;k&lt;vertex_number;k++) {<br>   for(i=0;i&lt;vertex_number;i++) {<pre><code>for(j=0;j&lt;vertex_number;j++) {
    if((graph[i][k]==-1) || (graph[k][j]==-1))     continue;
    if((min_graph[i][j]==-1) || (min_graph[i][j] &gt; graph[i][k]+graph[k][j]))
    {
        min_graph[i][j] = graph[i][k]+graph[k][j];     /*最短路径值*/ 
        path[i][j] = k;     /*最短路径*/ 
    }                
}
</code></pre>   }<br>}<br>}</li>
</ul>
<ol>
<li>拓扑排序<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        拓扑排序<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>//degree[]    每个结点的入度<br>//f[]              每个结点所在的层<br>void Toplogical_sort()<br>{<br>int i,j;<br>bool p=true;<br>top=0;<br>while(p) {<pre><code>p=false;
top++;
for(i=1;i&lt;=n;i++)
  if(degree[i]==0) {
          p=true;
          f[i]=top;
     }  
for(i=1;i&lt;=n;i++)
     if(f[i]==top) {
          for(j=1;j&lt;=n;j++)
               if(map[i][j])     degree[j]--;
          degree[i]=-1;   
     }         
</code></pre>}<br>top–;<br>} </li>
</ul>
<ol>
<li>网络预流和最大流<br>int rel[1000][10000];     //全局变量<br>int pre[1000];<br>//计算网络流</li>
</ol>
<p>//如果是二分图的匹配, 可以先对其进行网络预流以简化后续的查找<br>int pre_flow(int n,vector<int> * v)<br>{<br>     int ret = 0;<br>     int i,j,t,t1;</int></p>
<pre><code>for(i = 0 ; i &lt; v[0].size() ; i++){
     t = v[0][i];   //t是与节点0相邻接的点
     for(j = 0 ; j &lt; v[t].size() ; j++){
          t1 = v[t][j];     //与t相邻接的点
          if(rel[t1][n - 1] &gt; 0){
               ret++;
               rel[0][t]--, rel[t][0]++;
               rel[t][t1]--, rel[t1][t]++;
               rel[t1][n - 1]--, rel[n - 1][t1]++;
               break;
          }
     }
}     
return ret;
</code></pre><p>}<br>/<em><br>网络中求最大流<br>参数含义:    n代表网络中节点数,第0节点为源点, 第n－1节点为汇点<br>            rel是个二维数组, rel[i][j]代表从节点i到节点j的流量<br>            v[]是一个节点数组, v[i]包含与节点i相邻接的所有节点<br>返回值:        最大流量
</em>/<br>int max_flow(int n,vector<int> * v)<br>{<br>     int   ret = 0,i;<br>     int   t,t1,tm;<br>     queue<int> q;</int></int></p>
<pre><code>const int Infinite = 2000000000;

while(1){
     for(t = 0 ; t &lt; n ; t++)     pre[t] = -1;
     while(!q.empty()) q.pop();
     q.push(0);
     while(!q.empty()){  //find a augmenting path using breath-first search
          t = q.front();
          q.pop();
          if(t == n - 1) break;  //到达汇点
          for(i = 0 ; i &lt; v[t].size() ; i++){  //对于t相邻接的所有点查找可行路径
               t1 = v[t][i];
               if(rel[t][t1] &gt; 0 &amp;&amp; pre[t1] == -1){
                    pre[t1] = t;
                    q.push(t1);
               }
          }
     }
     if(q.empty() &amp;&amp; t != n - 1) break;
     tm = Infinite;      //此处寻找路径最小值在二分图中可省略
     while(t != 0){      //find the minimal num in the path
          t1 = pre[t];
          if(rel[t1][t] &lt; tm)     tm = rel[t1][t];
          t = t1;
     }
     //  tm = 1;  //二分图中
     t = n - 1;
     while(t != 0){           //change the relation
          t1 = pre[t];
          rel[t1][t] -= tm;
          rel[t][t1] += tm;
          t = t1;
     }
     ret += tm;
}
return ret;
</code></pre><p>}</p>
<ol>
<li>网络最小费用最大流<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong><br>网络中最小费用最大流<br>参数含义:    np代表网络中的总节点数, v是网络节点的邻接表<pre><code>cost为最后求得的最小费用, mf为求得的最大流
</code></pre>算法:    初始最小费用及最大流均为0，不断寻找可增广路</li>
</ol>
<p>增广路对应的单位费用最小并且可流<br>        修改残留网络及cost，mf. 直到无可增广路为止。<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>const int Max = 200000000;</p>
<p>vector<int> v[110];     //存储每个节点的邻接点<br>int flow[110][110];     //flow[i][j]代表由i节点到j节点的可行流量<br>int fcost[110][110];    //fcost[i][j]代表由i节点到j节点的单位流量费用<br>int ct[110];    //ct[i]代表单位容量到达i节点的最小费用<br>int pre[110];   //可行节点的前驱节点<br>void min_cost_max_flow(int np,const vector<int> * v,int &amp; cost,int &amp; mf)<br>{<br>     int t,t1,tm,i,j;<br>     bool out;</int></int></p>
<pre><code>cost = 0,mf = 0;
while(1){
     for(i = 0 ; i &lt; np ; i++)     pre[i] = -1,ct[i] = Max;
     ct[0] = 0;
     while(1){
          out = false;
          for(i = 0 ; i &lt; np ; i++){
               for(j = 0 ; j &lt; v[i].size() ; j++){
                    t = v[i][j];
                    if(flow[i][t] &gt; 0 &amp;&amp; ct[i] != Max &amp;&amp; ct[i] + fcost[i][t] &lt; ct[t]){
                         out = true;
                         ct[t] = ct[i] + fcost[i][t];
                         pre[t] = i;
                    }
               }
          }
          if(!out) break;
     }
     if(ct[np - 1] != Max){
          t = np - 1;
          tm = Max;      //此处寻找流量最小值
          while(t != 0){      //find the minimal num in the path
               t1 = pre[t];
               if(flow[t1][t] &lt; tm)     tm = flow[t1][t];
               t = t1;
          }
          mf += tm;              //流量增加
          t = np - 1;
          while(t != 0){           //change the relation
               t1 = pre[t];
               flow[t1][t] -= tm;
               flow[t][t1] += tm;
               cost += tm * fcost[t1][t];   //费用增加
               t = t1;
          }
     }
     else break;
}
</code></pre><p>}</p>
<ol>
<li>网络最大流(高度标号预流推进)<br>/*<br>函数接口:    int Relabel_To_Front(int s,int d)<br>参数含义:    s为源点，d为汇点<br>返回值  :    网络最大流</li>
</ol>
<p>调用函数前的初始化工作:ver置为网络中节点的个数，c[i][j]代表节点i到<br>节点j的流量，vl[i]存放i与相邻的所有节点<br>其它全局变量均初始化为零<br>*/<br>const int VEX = 405;  //网络中顶点数<br>const int HMAX = 810; //最大高度的定义,只要大于顶点的2倍就可以了</p>
<p>int f[VEX][VEX];  //流量<br>int c[VEX][VEX];  //边最大容量<br>int h[VEX];       //节点高度<br>int e[VEX];       //节点容量<br>int ver;          //节点数目<br>vector<int> vl[VEX];  //邻接表，vl[i]存放与i相邻的节点</int></p>
<p>void Push(int u,int v)  //流推进，由节点u推向v<br>{<br>     int cf = c[u][v] - f[u][v];   //u,v边的容量<br>     int d = e[u] &lt; cf ? e[u] : cf;</p>
<pre><code>f[u][v] += d;
f[v][u] = -f[u][v];
e[u] -= d;
e[v] += d;
</code></pre><p>}</p>
<p>void Relabel(int u)  //对u重新标号<br>{<br>     int i,t,cf;<br>     int hmin = HMAX;</p>
<pre><code>for(i = 0 ; i &lt; vl[u].size() ; i++){  //寻找相邻最低点
     t = vl[u][i];
     cf = c[u][t] - f[u][t];
     if(cf &gt; 0 &amp;&amp; h[u] &lt;= h[t] &amp;&amp; h[t] &lt; hmin)
          hmin = h[t];
}
h[u] = hmin + 1;
</code></pre><p>}</p>
<p>void Init_Preflow(int s)  //初始化网络流，s为源点<br>{<br>     int i;<br>     int u;</p>
<pre><code>h[s] = ver;  //初始化高度
for(i = 0 ; i &lt; vl[s].size() ; i++){
     u = vl[s][i];
     f[s][u] = c[s][u];
     f[u][s] = -c[s][u];
     e[u] = c[s][u];
     e[s] -= c[s][u];
}
</code></pre><p>}</p>
<p>void Discharge(int u)<br>{<br>     int i = 0;<br>     int cf,v;</p>
<pre><code>if(vl[u].size() == 0) return;
while(e[u] &gt; 0){
     if(i &lt; vl[u].size()) {
          v = vl[u][i];
          cf = c[u][v] - f[u][v];
     }
     if(i &gt;= vl[u].size()){
          Relabel(u);
          i = 0;
     }
     else if(cf &gt; 0 &amp;&amp; h[u] == h[v] + 1)
          Push(u,v);
     else
          i++;
}
</code></pre><p>}</p>
<p>int Relabel_To_Front(int s,int d) //s为源点，d为汇点<br>{<br>     int u,i,old_h;<br>     list<int> l;<br>     list<int>::iterator iter;</int></int></p>
<pre><code>Init_Preflow(s);

iter = l.begin();
for(i = 0 ; i &lt; ver ; i++){
     if(i != s &amp;&amp; i != d)
          l.insert(iter,i);
}
iter = l.begin();
while(iter != l.end()){
     u = *iter;
     old_h = h[u];
     Discharge(u);
     if(h[u] &gt; old_h){
          l.erase(iter);
          l.insert(l.begin(),u);
          iter = l.begin();
     }
     iter++;
}
return e[ver - 1];
</code></pre><p>}</p>
<ol>
<li>最大团<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :         最大团</li>
<li>Description :              ZJU 1492 Maximum Clique</li>
<li>团: 指G的一个完全子图, 该子图不包含在任何其他的完全子图当中</li>
<li>最大团: 指其中包含顶点最多的团<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<stdio.h><br>#include<string.h></string.h></stdio.h></li>
</ul>
<p>int joint[50][50];<br>int Size, MAX, DP[50];<br>bool find;<br>//返回－1表示邻接顶点集已经为空集,否则返回第一个公共顶点<br>int reachEnd(int start, int sets[])<br>{<br>     int lp;<br>     for(lp=start; lp&lt;Size ;lp++)<br>          if(sets[lp])     return lp;<br>     return -1;<br>}</p>
<p>void DFS(int Visit[], int start, int depth)<br>{<br>    int loop, first, sets[50], SET[50];<br>     memcpy(sets,Visit,Size<em>4);<br>     memcpy(SET,Visit,Size</em>4);<br>     if(( first=reachEnd(start,sets) ) == -1) {<br>          if(depth &gt; MAX) {<br>               MAX = depth;<br>               find = true;<br>        }<br>          return ;<br>     }<br>     while(first != -1) {<br>          if(depth + Size - start &lt;= MAX)//不可能找到最优解<br>               return ;<br>          if(depth + DP[first] &lt;= MAX)//不可能找到最优解<br>               return;<br>          sets[first] = 0;<br>          SET[first] = 0;//从邻接顶点集中清除first顶点<br>          for(loop=first+1; loop &lt; Size ;loop++)  //合并邻接顶点集<br>               if(SET[loop]==1 &amp;&amp; joint[first][loop]==1)     sets[loop]=1;<br>               else     sets[loop]=0;<br>          DFS(sets,first,depth+1);<br>          if(find)     return ;<br>          first = reachEnd(first,SET);//更新接点<br>     }<br>}</p>
<p>int main()<br>{<br>     int loop, lp, Visit[50];<br>     while(scanf(“%d”,&amp;Size)!=EOF &amp;&amp; Size!=0) {<br>          for(loop=0; loop &lt; Size ;loop++)<br>               for(lp=0; lp &lt; Size ;lp++)<br>                    scanf(“%d”,joint[loop]+lp);<br>          MAX=0;<br>          for(loop=Size-1; loop &gt;= 0 ;loop–) {<br>               find=false;<br>               memcpy(Visit, joint[loop], Size*4);<br>               DFS(Visit, loop, 1);<br>               DP[loop] = MAX;<br>          }<br>          printf(“%d\n”,DP[0]);<br>     }<br>}</p>
<ol>
<li>最大二分图匹配(匈牙利算法)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :  最大二分图匹配(匈牙利算法)</li>
<li>Description :       HDOJ 2063 过山车</li>
<li>二分图: 指所有顶点分成集合M和N, M或N中任意两个在同一集合中的点互不相连</li>
<li>匹配: 一组边顶点分别在两个集合中, 并且任意两条边都没有相同顶点</li>
<li>最大匹配: 所能得到的最大的边的个数<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<cstdio><br>#include<memory><br>#include<vector><br>using namespace std;<br>const int Max=1100;<br>vector&lt; vector<int> &gt; Bmap;<br>int n, m, k, nm;<br>int mark[Max];<br>bool flag[Max];</int></vector></memory></cstdio></li>
</ul>
<p>bool dfs(int pos)<br>{<br>    int i, pre, tp;<br>    for(i=0; i &lt; Bmap[pos].size() ;i++) {<br>        tp = Bmap[pos][i];<br>        if( !flag[tp] ) {<br>            flag[tp] = true;<br>            pre = mark[tp];<br>            mark[tp] = pos;<br>            if(pre==-1 || dfs(pre))     return true;<br>            mark[tp] = pre;<br>        }<br>    }<br>    return false;<br>}</p>
<p>inline int Max_Match()<br>{<br>    int mmax = 0, i;<br>    for(i=1; i &lt;= m ;i++) {<br>        memset(flag,0,sizeof(flag));<br>        if( dfs(i) )     mmax++;<br>    }<br>    return mmax;<br>}</p>
<p>int main()<br>{<br>    int i, j, id, id2;<br>    while(scanf(“%d”, &amp;k)==1 &amp;&amp; k) {<br>          scanf(“%d%d”,&amp;m, &amp;n);<br>          nm = n + m;<br>          Bmap.clear();     Bmap.resize(nm+10);<br>          memset(mark,-1,sizeof(mark));<br>          for(j=0; j &lt; k ;j++) {<br>               scanf(“%d %d”, &amp;id, &amp;id2);<br>               id2 += m;<br>               Bmap[id].push_back(id2);<br>          }<br>        printf(“%d\n”, Max_Match());<br>    }<br>}</p>
<p>第六章几何算法</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<ul>
<li>COMPUTATIONAL GEOMETRY ROUTINES</li>
<li>WRITTEN BY : LIU Yu (C) 2003<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>//    叉乘<br>//    两个点的距离 </li>
</ul>
<p>//    点到直线距离<br>//    返回直线 Ax + By + C =0  的系数<br>//    线段<br>//    圆<br>//    两个圆的公共面积<br>//    矩形<br>//    根据下标返回多边形的边<br>//    两个矩形的公共面积<br>//    多边形  ,逆时针或顺时针给出x,y<br>//    多边形顶点<br>//    多边形的边<br>//    多边形的周长<br>//    判断点是否在线段上<br>//    判断两条线断是否相交，端点重合算相交<br>//    判断两条线断是否平行<br>//    判断两条直线断是否相交<br>//    直线相交的交点<br>//    判断是否简单多边形<br>//    求多边形面积<br>//    判断是否在多边形上<br>//    判断是否在多边形内部<br>//    点阵的凸包，返回一个多边形 </p>
<p>//  最近点对的距离</p>
<p>#include <cmath></cmath></p>
<p>#include <cstdio></cstdio></p>
<p>#include <memory></memory></p>
<p>#include <algorithm></algorithm></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>typedef double TYPE;  //把double 定义为TYPE</p>
<p>#define Abs(x) (((x)&gt;0)?(x):(-(x)))  //用Abs()这个宏定义一个绝对值函数</p>
<p>#define Sgn(x) (((x)&lt;0)?(-1):(1)) //取相反数</p>
<p>#define Max(a,b) (((a)&gt;(b))?(a):(b)) //取大值</p>
<p>#define Min(a,b) (((a)&lt;(b))?(a):(b)) //取小值</p>
<p>#define Epsilon 1e-10 </p>
<p>#define Infinity 1e+10</p>
<p>#define Pi 3.14159265358979323846 //定义几个常量<br>TYPE Deg2Rad(TYPE deg)<br>{return (deg * Pi / 180.0);}  //把角度制转化为弧度制</p>
<p>TYPE Rad2Deg(TYPE rad)<br>{return (rad * 180.0 / Pi);}  //把弧度制转化为角度制</p>
<p>TYPE Sin(TYPE deg)<br>{return sin(Deg2Rad(deg));} //对弧度制求正弦</p>
<p>TYPE Cos(TYPE deg)<br>{return cos(Deg2Rad(deg));} //对弧度制求余弦</p>
<p>TYPE ArcSin(TYPE val)<br>{return Rad2Deg(asin(val));}  //求反正弦</p>
<p>TYPE ArcCos(TYPE val)<br>{ return Rad2Deg(acos(val));} //求反余弦</p>
<p>TYPE Sqrt(TYPE val)<br>{ return sqrt(val);}</p>
<p>struct POINT<br>{<br>    TYPE x;<br>    TYPE y;<br>    TYPE z;<br>    POINT() : x(0), y(0), z(0) {};<br>    POINT(TYPE <em>x</em>, TYPE <em>y</em>, TYPE <em>z</em> = 0) : x(<em>x</em>), y(<em>y</em>), z(<em>z</em>) {};<br>};</p>
<p>// cross product of (o-&gt;a) and (o-&gt;b)<br>// 叉乘<br>TYPE Cross(const POINT &amp; a, const POINT &amp; b, const POINT &amp; o)<br>{return (a.x - o.x) <em> (b.y - o.y) - (b.x - o.x) </em> (a.y - o.y);}  //叉积模板</p>
<p>// planar points’ distance<br>//  两个点的距离<br>TYPE Distance(const POINT &amp; a, const POINT &amp; b)<br>{return Sqrt((a.x - b.x) <em> (a.x - b.x) + (a.y - b.y) </em> (a.y - b.y) + (a.z - b.z) * (a.z - b.z));}</p>
<p>struct LINE<br>{<br>    POINT a;<br>    POINT b;<br>    LINE() {};<br>    LINE(POINT <em>a</em>, POINT <em>b</em>) : a(<em>a</em>), b(<em>b</em>) {};<br>};   //直线由两点决定</p>
<p>//点到直线距离<br>double PointToLine(POINT p0 ,POINT p1 ,POINT p2 ,POINT &amp;cp)<br>{<br>     double d = Distance(p1 ,p2);<br>     double s = Cross(p1 ,p2 ,p0) / d;<br>     cp.x = p0.x + s<em>( p2.y-p1.y) / d;<br>     cp.y = p0.y - s</em>( p2.x-p1.x) / d;<br>     return Abs(s);<br>}</p>
<p>// 返回直线 Ax + By + C =0  的系数<br>void Coefficient(const LINE &amp; L, TYPE &amp; A, TYPE &amp; B, TYPE &amp; C)<br>{<br>    A = L.b.y - L.a.y;<br>    B = L.a.x - L.b.x;<br>    C = L.b.x <em> L.a.y - L.a.x </em> L.b.y;<br>}</p>
<p>void Coefficient(const POINT &amp; p,const TYPE a,TYPE &amp; A,TYPE &amp; B,TYPE &amp; C)<br>{<br>    A = Cos(a);<br>    B = Sin(a);<br>    C = - (p.y <em> B + p.x </em> A);<br>}</p>
<p>// 线段<br>struct SEG<br>{<br>    POINT a;<br>    POINT b;<br>    SEG() {};<br>    SEG(POINT <em>a</em>, POINT <em>b</em>):a(<em>a</em>),b(<em>b</em>) {};<br>};</p>
<p>// 圆<br>struct CIRCLE<br>{<br>    TYPE x;<br>    TYPE y;<br>    TYPE r;<br>    CIRCLE() {}<br>    CIRCLE(TYPE <em>x</em>, TYPE <em>y</em>, TYPE <em>r</em>) : x(<em>x</em>), y(<em>y</em>), r(<em>r</em>) {}<br>};  //圆由圆心和半径组成</p>
<p>POINT Center(const CIRCLE &amp; circle)<br>{ return POINT(circle.x, circle.y);}  //返回的是一个POINT类型的对象，他这里没有直接设出一个具体的对象，而是直接用类名来实现，也是可以的，而且他这里是把对象传递进来，返回的是他的圆心</p>
<p>//圆的面积<br>TYPE Area(const CIRCLE &amp; circle)<br>{ return Pi <em> circle.r </em> circle.r;}</p>
<p>//两个圆的公共面积<br>TYPE CommonArea(const CIRCLE &amp; A, const CIRCLE &amp; B)<br>{<br>    TYPE area = 0.0;</p>
<pre><code>const CIRCLE &amp; M = (A.r &gt; B.r) ? A : B;
const CIRCLE &amp; N = (A.r &gt; B.r) ? B : A;  //按照圆半径的大小来把圆区分开来

TYPE D = Distance(Center(M), Center(N));

if ((D &lt; M.r + N.r) &amp;&amp; (D &gt; M.r - N.r)) //判断出两个圆之间的关系是相交的
{
    TYPE cosM = (M.r * M.r + D * D - N.r * N.r) / (2.0 * M.r * D);
    TYPE cosN = (N.r * N.r + D * D - M.r * M.r) / (2.0 * N.r * D);

    TYPE alpha = 2.0 * ArcCos(cosM);
    TYPE beta  = 2.0 * ArcCos(cosN);

    TYPE TM = 0.5 * M.r * M.r * Sin(alpha);
    TYPE TN = 0.5 * N.r * N.r * Sin(beta);

    TYPE FM = (alpha / 360.0) * Area(M);
    TYPE FN = (beta / 360.0) * Area(N);

    area = FM + FN - TM - TN;
</code></pre><p>  }//相交圆的公共部分的面积就是通过一个扇形的面积减去三角形积 ，然后把这两个部分相加得到</p>
<p>   else if (D &lt;= M.r - N.r) //如果两圆是内含的关系，那么公共圆的面积就是一个圆的面积<br>    {<br>        area = Area(N);<br>    }<br>    return area;<br>}</p>
<p>//    矩形<br>//    矩形的线段<br>//        2<br>//    ————— b<br>//    |          |<br>//   3 |          |  1<br>//   a —————<br>//         0</p>
<p>struct RECT<br>{<br>    POINT a;                                   // 左下点<br>    POINT b;                                   // 右上点<br>    RECT() {};<br>    RECT(const POINT &amp; <em>a</em>, const POINT &amp; <em>b</em>)<br>    {a = <em>a</em>; b = <em>b</em>;}<br>};</p>
<p>//根据下标返回多边形的边 （没有看懂是干什么的，或者说是具体怎么操作的）<br>SEG Edge(const RECT &amp; rect, int idx) //SEG是线段<br>{<br>    SEG edge;<br>    while (idx &lt; 0) idx += 4;<br>    switch (idx % 4)<br>    {<br>    case 0:<br>        edge.a = rect.a;<br>        edge.b = POINT(rect.b.x, rect.a.y);<br>        break;<br>    case 1:<br>        edge.a = POINT(rect.b.x, rect.a.y);<br>        edge.b = rect.b;<br>        break;<br>    case 2:<br>        edge.a = rect.b;<br>        edge.b = POINT(rect.a.x, rect.b.y);<br>        break;<br>    case 3:<br>        edge.a = POINT(rect.a.x, rect.b.y);<br>        edge.b = rect.a;<br>        break;<br>    default:<br>        break;<br>    }<br>    return edge;<br>}</p>
<p>TYPE Area(const RECT &amp; rect)<br>{return (rect.b.x - rect.a.x) * (rect.b.y - rect.a.y);}</p>
<p>//  两个矩形的公共面积<br>TYPE CommonArea(const RECT &amp; A, const RECT &amp; B)<br>{<br>    TYPE area = 0.0;</p>
<pre><code>POINT LL(Max(A.a.x, B.a.x), Max(A.a.y, B.a.y)); 
POINT UR(Min(A.b.x, B.b.x), Min(A.b.y, B.b.y)); //这里很妙，可以直接把相交部分的左下方的点与右上方的点的坐标求出来

if ((LL.x &lt;= UR.x) &amp;&amp; (LL.y &lt;= UR.y))  //判断是否两个矩形是否相交
{
    area = Area(RECT(LL, UR));
}
return area;
</code></pre><p>}</p>
<p>// 多边形  ,逆时针或顺时针给出x,y<br>struct POLY<br>{<br>    int n;        //n个点<br>    TYPE <em> x;     //x,y为点的指针，首尾必须重合<br>    TYPE </em> y;<br>    POLY() : n(0), x(NULL), y(NULL) {};<br>    POLY(int <em>n</em>, const TYPE <em> <em>x</em>, const TYPE </em> <em>y</em>)<br>    {<br>        n = <em>n</em>;<br>        x = new TYPE[n + 1];<br>        memcpy(x, <em>x</em>, n*sizeof(TYPE));<br>        x[n] = <em>x</em>[0];</p>
<pre><code>    y = new TYPE[n + 1];
    memcpy(y, _y_, n*sizeof(TYPE));
    y[n] = _y_[0];
}
</code></pre><p>};</p>
<p>//多边形顶点<br>POINT Vertex(const POLY &amp; poly, int idx)<br>{<br>    idx %= poly.n;  //idx应该指的是点的个数<br>    return POINT(poly.x[idx], poly.y[idx]);  //由于POLY里面的x,y是指针，那么就相当于是关于多边形顶点的坐标的一个数组，用来记录下所有多边形顶点的坐标信息<br>}</p>
<p>//多边形的边<br>SEG Edge(const POLY &amp; poly, int idx)<br>{<br>    idx %= poly.n;<br>    return SEG(POINT(poly.x[idx], poly.y[idx]),<br>        POINT(poly.x[idx + 1], poly.y[idx + 1]));<br>} </p>
<p>//多边形的周长<br>TYPE Perimeter(const POLY &amp; poly)<br>{<br>    TYPE p = 0.0;<br>    for (int i = 0; i &lt; poly.n; i++)<br>        p = p + Distance(Vertex(poly, i), Vertex(poly, i + 1));<br>    return p;<br>}</p>
<p>bool IsEqual(TYPE a, TYPE b)<br>{return (Abs(a - b) &lt; Epsilon);} //基础的用于判断两个数是否相等</p>
<p>bool IsEqual(const POINT &amp; a, const POINT &amp; b)<br>{return (IsEqual(a.x, b.x) &amp;&amp; IsEqual(a.y, b.y));}  //重载一下用于判断两个点是否相等</p>
<p>bool IsEqual(const LINE &amp; A, const LINE &amp; B)<br>{<br>    TYPE A1, B1, C1;<br>    TYPE A2, B2, C2;</p>
<pre><code>Coefficient(A, A1, B1, C1);  //把直线A的系数返回给A1,B1,C1
Coefficient(B, A2, B2, C2);

return IsEqual(A1 * B2, A2 * B1) &amp;&amp; 
    IsEqual(A1 * C2, A2 * C1) &amp;&amp;
    IsEqual(B1 * C2, B2 * C1);
</code></pre><p>}  //判断两条直线是否相等</p>
<p>// 判断点是否在线段上<br>bool IsOnSeg(const SEG &amp; seg, const POINT &amp; p)<br>{<br>    return (IsEqual(p, seg.a) || IsEqual(p, seg.b)) ||<br>        (((p.x - seg.a.x) <em> (p.x - seg.b.x) &lt; 0 ||<br>        (p.y - seg.a.y) </em> (p.y - seg.b.y) &lt; 0) &amp;&amp;<br>        (IsEqual(Cross(seg.b, p, seg.a), 0)));<br>}  //前面两个IsEqual是用来说明要判断的点是否就是直线的一个端点，中间两个用于判断这个点是否会在线的延长线上，最后一个用于判断三点是否共线。只有这样才能有效的保证点落在线段上</p>
<p>//判断两条线断是否相交，端点重合算相交<br>bool IsIntersect(const SEG &amp; u, const SEG &amp; v)<br>{<br>    return (Cross(v.a, u.b, u.a) <em> Cross(u.b, v.b, u.a) &gt;= 0) &amp;&amp;<br>        (Cross(u.a, v.b, v.a) </em> Cross(v.b, u.b, v.a) &gt;= 0) &amp;&amp;<br>        (Max(u.a.x, u.b.x) &gt;= Min(v.a.x, v.b.x)) &amp;&amp;<br>        (Max(v.a.x, v.b.x) &gt;= Min(u.a.x, u.b.x)) &amp;&amp;<br>        (Max(u.a.y, u.b.y) &gt;= Min(v.a.y, v.b.y)) &amp;&amp;<br>        (Max(v.a.y, v.b.y) &gt;= Min(u.a.y, u.b.y));<br>} //后面的四个比较用于限定线段相交时的一些点坐标之间的关系，只有这样限定后才可以保证线段相交，否则如果没有这四个条件的话，只能保证的是直线的相交。。。</p>
<p>//判断两条线断是否平行<br>bool IsParallel(const LINE &amp; A, const LINE &amp; B)<br>{<br>    TYPE A1, B1, C1;<br>    TYPE A2, B2, C2;</p>
<pre><code>Coefficient(A, A1, B1, C1);
Coefficient(B, A2, B2, C2);

return (A1 * B2 == A2 * B1) &amp;&amp; 
    ((A1 * C2 != A2 * C1) || (B1 * C2 != B2 * C1));
</code></pre><p>}  //只要系数成比例就行</p>
<p>//判断两条直线断是否相交<br>bool IsIntersect(const LINE &amp; A, const LINE &amp; B)<br>{return !IsParallel(A, B);} //不平行就相交</p>
<p>//直线相交的交点<br>POINT Intersection(const LINE &amp; A, const LINE &amp; B)<br>{<br>    TYPE A1, B1, C1;<br>    TYPE A2, B2, C2;</p>
<pre><code>Coefficient(A, A1, B1, C1);
Coefficient(B, A2, B2, C2);

POINT I(0, 0);
I.x = - (B2 * C1 - B1 * C2) / (A1 * B2 - A2 * B1);
I.y =   (A2 * C1 - A1 * C2) / (A1 * B2 - A2 * B1);
return I;
</code></pre><p>}</p>
<p>//判断矩形是否在圆内<br>bool IsInCircle(const CIRCLE &amp; circle, const RECT &amp; rect)<br>{<br>    return (circle.x - circle.r &gt;= rect.a.x) &amp;&amp;<br>        (circle.x + circle.r &lt;= rect.b.x) &amp;&amp;<br>        (circle.y - circle.r &gt;= rect.a.y) &amp;&amp;<br>        (circle.y + circle.r &lt;= rect.b.y);<br>}</p>
<p>//判断是否简单多边形<br>bool IsSimple(const POLY &amp; poly)<br>{<br>    if (poly.n &lt; 3)<br>        return false;<br>    SEG L1, L2;<br>    for (int i = 0; i &lt; poly.n - 1; i++)<br>    {<br>        L1 = Edge(poly, i); //用Edge取出多边形的边<br>        for (int j = i + 1; j &lt; poly.n; j++) //用二重循环来对多边形上的边进行一一判断<br>        {<br>            L2 = Edge(poly, j);<br>            if (j == i + 1)  //相邻的两条边进行比较<br>            {<br>                if (IsOnSeg(L1, L2.b) || IsOnSeg(L2, L1.a))  return false;  //如果第二条直线的右边的点在第一条直线上或者第一条直线的坐边的点缀第二条直线上，说明这个多边形是凹的，不是简单的<br>            }<br>            else if (j == poly.n - i - 1)  //同上面的一样，不过这里取出的是左边的相邻直线<br>            {<br>                if (IsOnSeg(L1, L2.a) || IsOnSeg(L2, L1.b))  return false;<br>            }<br>            else<br>            {<br>                if (IsIntersect(L1, L2))  return false; //不相邻的直线但是相交，那么说明非简单<br>            }<br>        } // for j<br>    } // for i<br>    return true;<br>}</p>
<p>//求多边形面积<br>TYPE Area(const POLY &amp; poly)<br>{<br>    if (poly.n &lt; 3) return TYPE(0); //如果边数小于3说明非多边形，没有面积可言<br>    double s = poly.y[0] <em> (poly.x[poly.n - 1] - poly.x[1]);<br>    for (int i = 1; i &lt; poly.n; i++)<br>    {<br>        s += poly.y[i] </em> (poly.x[i - 1] - poly.x[(i + 1) % poly.n]);<br>    }<br>    return s/2;<br>}  //把多边形分割成三角形的和，不过这里的面积计算的方法没有看懂</p>
<p>//判断点是否在多边形上<br>bool IsOnPoly(const POLY &amp; poly, const POINT &amp; p)<br>{<br>    for (int i = 0; i &lt; poly.n; i++)<br>    {<br>        if (IsOnSeg(Edge(poly, i), p))  return true;<br>    }<br>    return false;<br>}</p>
<p>//判断点是否在多边形内部<br>bool IsInPoly(const POLY &amp; poly, const POINT &amp; p)<br>{<br>    SEG L(p, POINT(Infinity, p.y)); //Infinity==1e+10，L这条直线相当于是过p点且平行于x轴的直线<br>    int count = 0;<br>    for (int i = 0; i &lt; poly.n; i++)<br>    {<br>        SEG S = Edge(poly, i);<br>        if (IsOnSeg(S, p))<br>        {<br>            return false;                        //如果想让 在poly上则返回 true,则改为true<br>        }//点在多边形的边上，非内部，返回false<br>        if (!IsEqual(S.a.y, S.b.y))<br>        {<br>            POINT &amp; q = (S.a.y &gt; S.b.y)?(S.a):(S.b);  //q取这条多边形边上y坐标大的点<br>            if (IsOnSeg(L, q))<br>            {<br>                ++count;<br>            }<br>            else if (!IsOnSeg(L, S.a) &amp;&amp; !IsOnSeg(L, S.b) &amp;&amp; IsIntersect(S, L))<br>            {<br>                ++count;<br>            }<br>        }<br>    }<br>    return (count % 2 != 0);<br>}//这里用count这个计数器的奇偶来判断点是否在多边形内没有看懂</p>
<p>// 点阵的凸包，返回一个多边形 ，Graham-scan算法<br>POLY ConvexHull(const POINT <em> set, int n)            // 不适用于点少于三个的情况<br>{<br>    POINT </em> points = new POINT[n];<br>    memcpy(points, set, n * sizeof(POINT));</p>
<pre><code>TYPE * X = new TYPE[n];
TYPE * Y = new TYPE[n];

int i, j, k = 0, top = 2;
for(i = 1; i &lt; n; i++)
{
    if ((points[i].y &lt; points[k].y) ||
        ((points[i].y == points[k].y) &amp;&amp;
        (points[i].x &lt; points[k].x)))
    {
        k = i;
    }
} //找到p0点，一般取y坐标最小，如果y相同则取x坐标最小，即最左边的点

std::swap(points[0], points[k]); 

for (i = 1; i &lt; n - 1; i++)
{
    k = i;
    for (j = i + 1; j &lt; n; j++)
    {
        if ((Cross(points[j], points[k], points[0]) &gt; 0) ||
            ((Cross(points[j], points[k], points[0]) == 0) &amp;&amp;
            (Distance(points[0], points[j]) &lt; Distance(points[0], points[k]))))
        {
            k = j;
        }
    }
    std::swap(points[i], points[k]);
}

X[0] = points[0].x; Y[0] = points[0].y;
X[1] = points[1].x; Y[1] = points[1].y;
X[2] = points[2].x; Y[2] = points[2].y;

for (i = 3; i &lt; n; i++)
{
    while (Cross(points[i], POINT(X[top], Y[top]), 
        POINT(X[top - 1], Y[top - 1])) &gt;= 0)
    {
        top--;
    }
    ++top;
    X[top] = points[i].x;
    Y[top] = points[i].y;
}

delete [] points;
POLY poly(++top, X, Y);
delete [] X;
delete [] Y;
return poly;
</code></pre><p>}</p>
<p>//最近点对的距离, Written By PrincessSnow</p>
<p>#define MAXN 100000<br>POINT pt[MAXN];</p>
<p>bool cmp(POINT n1, POINT n2)<br>{return (n1.x&lt;n2.x || n1.x==n2.x &amp;&amp; n1.y&lt;n2.y);}</p>
<p>double Get(double dis, int mid, int start, int end)<br>{<br>    int s=mid, e=mid, i, j;<br>    double t;<br>    while(s &gt; start &amp;&amp; pt[mid].x - pt[s].x &lt;= dis)     s–;<br>    while(e &lt; end &amp;&amp; pt[e].x - pt[mid].x &lt;= dis)     e++;<br>    for(i=s; i &lt;= e; i++)<br>        for(j=i+1; j &lt;= e &amp;&amp; j &lt;= i+7; j++) {<br>            t = Distance(pt[i], pt[j]);<br>            if(t &lt; dis)     dis=t;<br>        }<br>     return dis;<br>}</p>
<p>double ClosestPairDistance(int start, int end)<br>{<br>    int m = end-start+1, mid, i;<br>    double t1, t2, dis=-1, t;<br>    if(m &lt;= 3) {<br>        for(i=start; i &lt; end; i++) {<br>            t = Distance(pt[i] , pt[i+1]);<br>            if(t &lt; dis || dis == -1)     dis = t;<br>        }<br>        t = Distance(pt[start] , pt[end]);<br>        if(t &lt; dis) dis=t;<br>        return dis;<br>    }</p>
<pre><code>if(m%2 == 0)     mid = start + m/2 - 1;
else               mid = start + m/2;
if(m%2 == 0) {
    t1 = ClosestPairDistance(start, mid);
    t2 = ClosestPairDistance(mid+1, end);
}
else {
    t1 = ClosestPairDistance(start, mid);
    t2 = ClosestPairDistance(mid+1, end);
}
if(t1 &lt; t2)     dis = t1;
else          dis = t2;
dis = Get(dis, mid, start, end);
return dis;
</code></pre><p>}</p>
<ol>
<li>球面上两点最短距离<br>// 计算圆心角lat表示纬度, -90 &lt;= w &lt;= 90, lng表示经度<br>// 返回两点所在大圆劣弧对应圆心角, 0 &lt;= angle &lt;= pi<br>double angle(double lng1, double lat1, double lng2, double lat2)<br>{<br>double dlng = fabs(lng1 - lng2) <em> pi / 180;<br>while(dlng &gt;= pi+pi)     dlng -= pi+pi;<br>if(dlng &gt; pi)     dlng = pi + pi - dlng;<br>lat1 </em>= pi / 180,     lat2 <em>= pi / 180;<br>return acos( cos(lat1)</em>cos(lat2)<em>cos(dlng) + sin(lat1)</em>sin(lat2) );<br>}</li>
</ol>
<p>// 计算距离, r为球半径<br>double line_dist(double r, double lng1, double lat1, double lng2, double lat2)<br>{<br>    double dlng = fabs(lng1 - lng2) <em> pi / 180;<br>     while(dlng &gt;= pi+pi)     dlng -= pi+pi;<br>    if(dlng &gt; pi)     dlng = pi + pi - dlng;<br>    lat1 </em>= pi / 180,     lat2 <em>= pi / 180;<br>    return r </em> sqrt( 2 - 2<em>( cos(lat1)</em>cos(lat2)<em>cos(dlng) + sin(lat1)</em>sin(lat2) ) );<br>}</p>
<p>// 计算球面距离, r为球半径<br>double sphere_dist(double r, double lng1, double lat1, double lng2, double lat2)<br>{<br>    return r * angle(lng1, lat1, lng2, lat2);<br>}</p>
<ol>
<li><p>三点求圆心坐标<br>double GetRadiusBy3Points(double x1, double y1, </p>
<pre><code>double x2, double y2, 
double x3, double y3, 
double &amp;x, double &amp;y) 
</code></pre><p>{<br>// 由 ( x - x1 )^2 + ( y - y1 )^2 = ( x - x2 )^2 + ( y - y2 )^2 得<br>// 2<em>( x2 - x1 )</em>x + 2<em>( y2 - y1 )</em>y = x2^2 - x1^2 + y2^2 - y1^2<br>// 同理得<br>// 2<em>( x3 - x2 )</em>x + 2<em>( y3 - y2 )</em>y = x3^2 - x2^2 + y3^2 - y2^2<br>// 由行列式解方程得 x , y<br>double a11, a12, a21, a22, b1, b2;<br>double d, d1, d2 ;<br>a11 = 2 <em> ( x3 - x2 );<br>a12 = 2 </em> ( y3 - y2 );<br>a21 = 2 <em> ( x2 - x1 );<br>a22 = 2 </em> ( y2 - y1 ); </p>
<p>b1 = x3<em>x3 - x2</em>x2 + y3<em>y3 - y2</em>y2;<br>b2 = x2<em>x2 - x1</em>x1 + y2<em>y2 - y1</em>y1; </p>
<p>d = a11<em>a22 - a12</em>a21;<br>d1 = b1<em>a22 - a12</em>b2;<br>d2 = a11<em>b2 - b1</em>a21;<br>// x , y 是圆心坐标<br>x = d1 / d;<br>y = d2 / d;<br>return  (x1 - x)<em>(x1 - x) + (y1 - y)</em>(y1 - y);<br>}</p>
</li>
</ol>
<p>第七章专题讨论</p>
<ol>
<li>树状数组</li>
</ol>
<p>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></p>
<ul>
<li>Function Name :         树状数组</li>
<li><p>Description :                     HDOJ 1166 敌兵布阵</p>
</li>
<li><p>减少冗余统计, 是线段树的一种变化<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<cstdio><br>int data[50001], s[50001], T[50001];</cstdio></p>
</li>
</ul>
<p>inline int lowbit(int t)<br>{return t &amp; (-t);}</p>
<p>inline int sum(int end)<br>{<br>     int sum = 0;<br>     while(end &gt; 0) {<br>          sum += T[end];<br>          end -= lowbit(end);<br>     }<br>     return sum;<br>}</p>
<p>inline void plus(int pos, int num, int count)<br>{<br>     while(pos &lt;= count) {<br>          T[pos] += num;<br>          pos += lowbit(pos);<br>     }<br>}</p>
<p>int main()<br>{<br>     char buffer[10];<br>     int i, j, t, n, a, b;<br>     scanf(“%d”, &amp;t);<br>     for(i=1; i &lt;= t ;i++) {<br>          scanf(“%d”, &amp;n);<br>          T[0] = s[0] = data[0] = 0;<br>          for(j=1; j &lt;= n ;j++) {<br>               scanf(“%d”, &amp;data[j]);<br>               s[j] = s[j - 1] + data[j];<br>               T[j] = s[j] - s[j - lowbit(j)];<br>          }<br>          printf(“Case %d:\n”, i);<br>          while(scanf(“%s”, buffer) == 1 &amp;&amp; buffer[0] != ‘E’) {<br>               scanf(“%d%d”, &amp;a, &amp;b);<br>               switch(buffer[0]) {<br>               case ‘Q’:<br>                    printf(“%d\n”, sum(b) - sum(a) + data[a]); break;<br>               case ‘A’:<br>                    plus(a, b, n); data[a] += b;       break;<br>               case ‘S’:<br>                    plus(a, -b, n); data[a] -= b; break;<br>               }<br>          }<br>     }<br>}</p>
<ol>
<li>字典树<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        字典树(多路查找树)</li>
<li><p>Description :                     HDOJ 1075 What Are You Talking About</p>
</li>
<li><p>易于字符保存, 插入和查找, 时间复杂度都是线性<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include <cstdio><br>#include <string><br>using namespace std;</string></cstdio></p>
</li>
</ul>
<p>struct trie<br>{<br>    trie <em> next[26];<br>    int index;<br>};<br>trie </em>thead;<br>char dic[1000000][20];</p>
<p>inline trie <em> newnode()<br>{<br>    int i;<br>    trie </em>t;<br>    t=(trie*)malloc(sizeof(trie));<br>    memset(t,0,sizeof(trie));<br>    return t;<br>}</p>
<p>void insert(trie <em> s,char x[],int pos)<br>{<br>    int i;<br>    trie </em>t;<br>    for(i=0; x[i] ; i++) {<br>        if( s-&gt;next[ x[i]-‘a’ ] )     s=s-&gt;next[ x[i]-‘a’ ];<br>        else {<br>            t=newnode();<br>            s-&gt;next[ x[i]-‘a’ ]=t;<br>            s=t;<br>        }<br>    }//for<br>    s-&gt;index=pos;<br>}</p>
<p>void deltrie(trie * s)<br>{<br>    int i;<br>    for(i=0; i &lt; 26 ;i++) {<br>        if( s-&gt;next[i] )<br>            deltrie(s-&gt;next[i]);<br>    }<br>    free(s);<br>    s=NULL;<br>}</p>
<p>int find(trie *s, char x[])<br>{<br>    int i;<br>    if(x[0] == 0)     return -1;<br>    for(i=0; x[i] ; i++) {<br>        if( s-&gt;next[ x[i]-‘a’ ] )     s=s-&gt;next[ x[i]-‘a’ ];<br>        else                              break;<br>    }<br>    if(x[i]==0)     return s-&gt;index;<br>    else          return -1;<br>}</p>
<p>int main()<br>{<br>    int t,n,i,j,all;<br>    char word[20],mars[20],ch;</p>
<pre><code>thead=newnode();
while(scanf(&quot;%s&quot;,word)==1)
    if(word[0]==&apos;S&apos;)     break;
 i=1;
 while(scanf(&quot;%s&quot;,dic[i])==1 &amp;&amp; dic[i][0]!=&apos;E&apos;) {
      scanf(&quot;%s&quot;,mars);
      insert(thead,mars,i);
      i++;
 }
 all=i;
 while(scanf(&quot;%s&quot;,word)==1)
      if(word[0]==&apos;S&apos;)     break;
 getchar();     j=0;
 while(scanf(&quot;%c&quot;,&amp;ch)==1 &amp;&amp; ch!=&apos;E&apos;) {
      if(ch&gt;=&apos;a&apos; &amp;&amp; ch&lt;=&apos;z&apos;) {
           mars[j]=ch;     j++;   
      }
      else {
           mars[j]=0;
           t=find( thead , mars );
           j=0;
           if(t&gt;0)     printf(&quot;%s&quot;,dic[t]);
           else if(mars[0]!=0)   printf(&quot;%s&quot;,mars);
           printf(&quot;%c&quot;,ch);
           }
 }//while
 deltrie(thead);
</code></pre><p>}</p>
<ol>
<li>后缀树</li>
</ol>
<p>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></p>
<ul>
<li>Function Name :         后缀树</li>
<li>Description :              PKU 2774 Long Long Message</li>
<li>有效的支持字符串匹配和查询<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<cstdio><br>#include<string></string></cstdio></li>
</ul>
<p>#define NUM                    27</p>
<p>#define STARTCHAR          ‘a’</p>
<p>#define SPECIALCHAR     ‘{‘</p>
<p>#define ERROR               -1</p>
<p>#define TYPE1               1</p>
<p>#define TYPE2               2</p>
<p>#define LEAF               1</p>
<p>#define NOTLEAF               2</p>
<p>struct SuffixTrie {<br>     int Start, End;<br>     SuffixTrie <em> Next[NUM];<br>     SuffixTrie </em> Link;<br>     SuffixTrie * Father;<br>     int Flag;<br>     int Length;<br>};</p>
<p>char str[100010], buf[100010];<br>SuffixTrie head;<br>SuffixTrie<em>P, </em>G, <em>U, </em>V, *q;<br>int W[3], len, len2;</p>
<p>void CreateNode(SuffixTrie <em> &amp; Node) {<br>    int i;<br>    Node = (SuffixTrie </em> ) malloc(sizeof(SuffixTrie));<br>    Node -&gt; Start = Node -&gt; End = Node -&gt; Length = ERROR;<br>    for (i = 0; i &lt; NUM; i++) Node -&gt; Next[i] = NULL;<br>    Node -&gt; Link = Node -&gt; Father = NULL;<br>    Node -&gt; Flag = LEAF;<br>}</p>
<p>void Init(SuffixTrie &amp; h, char s[]) {<br>    int i;<br>    h.Start = h.End = ERROR;<br>    for (i = 0; i &lt; NUM; i++) h.Next[i] = NULL;<br>    h.Link = &amp; h;<br>    h.Father = NULL;<br>    h.Flag = LEAF;<br>    h.Length = 0;</p>
<pre><code>len = strlen(s);
s[len] = SPECIALCHAR;
s[len + 1] = &apos;\0&apos;;
len++;
</code></pre><p>}</p>
<p>int FindV(char s[]) {<br>    int old;<br>    SuffixTrie <em> t, </em> newt;<br>    t = U -&gt; Next[s[W[0]] - STARTCHAR];</p>
<pre><code>old = 0;
while (W[2] &gt; (t -&gt; End) - (t -&gt; Start) + 1 + old) {
    old += (t -&gt; End - t -&gt; Start + 1);
    t = t -&gt; Next[s[W[0] + old] - STARTCHAR];
}
if (W[2] == (t -&gt; End) - (t -&gt; Start) + 1 + old) {
    V = t;
    P -&gt; Link = V;
    return TYPE1;
} else {
    CreateNode(newt);
    newt -&gt; Start = t -&gt; Start;
    newt -&gt; End = t -&gt; Start + W[2] - old - 1;
    newt -&gt; Father = t -&gt; Father;
    newt -&gt;
           Length = newt -&gt; Father -&gt; Length + newt -&gt; End - newt -&gt;
           Start + 1;
    t -&gt; Father -&gt; Next[s[t -&gt; Start] - STARTCHAR] = newt;
    t -&gt; Start = newt -&gt; End + 1;
    newt -&gt; Next[s[t -&gt; Start] - STARTCHAR] = t;
    t -&gt; Father = newt;
    V = newt;
    P -&gt; Link = V;
    return TYPE2;
}
</code></pre><p>}</p>
<p>int Insert(SuffixTrie <em> Node, int start, char s[]) {<br>    int i, posbegin, posend;<br>    SuffixTrie </em> t;<br>    if (Node -&gt; Next[s[start] - STARTCHAR] == NULL) {<br>        CreateNode(Node -&gt; Next[s[start] - STARTCHAR]);<br>        Node -&gt; Next[s[start] - STARTCHAR] -&gt; Start = start;<br>        Node -&gt; Next[s[start] - STARTCHAR] -&gt; End = len - 1;<br>        Node -&gt; Next[s[start] - STARTCHAR] -&gt; Father = Node;<br>        Node -&gt; Next[s[start] - STARTCHAR] -&gt;<br>               Length = Node -&gt; Length + len - start;<br>        Node -&gt; Flag = NOTLEAF;<br>        P = Node;<br>        return TYPE1;<br>    } else {<br>        posbegin = Node -&gt; Next[s[start] - STARTCHAR] -&gt; Start;<br>        posend = Node -&gt; Next[s[start] - STARTCHAR] -&gt; End;<br>        for (i = posbegin; i &lt;= posend; i++) {<br>            if (s[i] != s[start + i - posbegin]) break;<br>        }<br>        if (i == posend + 1) {<br>            return Insert(Node -&gt; Next[s[start] - STARTCHAR], start + i - posbegin, s);<br>        } else {<br>            CreateNode(t);<br>            t -&gt; Start = posbegin;<br>            t -&gt; End = i - 1;<br>            t -&gt; Flag = NOTLEAF;<br>            Node -&gt; Next[s[start] - STARTCHAR] -&gt; Start = i;<br>            t -&gt; Next[s[i] - STARTCHAR] = Node -&gt; Next[s[start] - STARTCHAR];<br>            t -&gt; Next[s[i] - STARTCHAR] -&gt; Father = t;<br>            Node -&gt; Next[s[start] - STARTCHAR] = t;<br>            t -&gt; Father = Node;<br>            t -&gt; Length = Node -&gt; Length + t -&gt; End - t -&gt; Start + 1;<br>            Insert(t, start + i - posbegin, s);<br>            G = Node;<br>            P = t;<br>            return TYPE2;<br>        }<br>    }<br>}</p>
<p>int Select(int start, char s[], int type) {<br>    int result1, result2, result;<br>    if (type == TYPE1) {<br>        U = P -&gt; Link;<br>        result = Insert(U, start + U -&gt; Length, s);<br>    } else {<br>        U = G -&gt; Link;<br>        if (G -&gt; Link == G) {<br>            W[0] = P -&gt; Start + 1;<br>            W[1] = P -&gt; End;<br>            W[2] = P -&gt; End - P -&gt; Start;<br>        } else {<br>            W[0] = P -&gt; Start;<br>            W[1] = P -&gt; End;<br>            W[2] = P -&gt; End - P -&gt; Start + 1;<br>        }<br>        if (W[2] == 0) {<br>            V = G;<br>            P -&gt; Link = V;<br>            result = Insert(V, start, s);<br>        } else {<br>            result1 = FindV(s);<br>            result2 = Insert(V, start + V -&gt; Length, s);<br>            if (result1 == TYPE2) {<br>                G = P -&gt; Father;<br>                result = result1;<br>            } else result = result2;<br>        }<br>    }<br>    return result;<br>}</p>
<p>void BuildSuffixTrie(SuffixTrie &amp; h, char s[]) {<br>    int i;<br>    int type;</p>
<pre><code>len = strlen(s);
CreateNode(h.Next[s[0] - STARTCHAR]);
h.Next[s[0] - STARTCHAR] -&gt; Start = 0;
h.Next[s[0] - STARTCHAR] -&gt; End = len - 1;
h.Next[s[0] - STARTCHAR] -&gt; Father = &amp; h;
h.Next[s[0] - STARTCHAR] -&gt; Length = h.Length + h.Next[s[0] - STARTCHAR] -&gt; End - h.Next[s[0] - STARTCHAR] -&gt; Start + 1;
h.Flag = NOTLEAF;
type = TYPE1;
P = &amp; h;

for (i = 1; i &lt; len; i++) type = Select(i, s, type);
</code></pre><p>}</p>
<p>void DeleteSuffixTrie(SuffixTrie * &amp; Node) {<br>    int i;<br>    for (i = 0; i &lt; NUM; i++) {<br>        if (Node -&gt; Next[i] != NULL) {<br>            DeleteSuffixTrie(Node -&gt; Next[i]);<br>            Node -&gt; Next[i] = NULL;<br>        }<br>    }<br>    free(Node);<br>}</p>
<p>int FindString(int start, char s[]) {<br>    int result;<br>    int i;<br>    int temp;<br>    SuffixTrie * x;<br>    x = P -&gt; Next[s[start] - STARTCHAR];<br>    result = P -&gt; Length;<br>    if (x == NULL) {<br>        P = P -&gt; Link;<br>        return result;<br>    }<br>    temp = 0;<br>    for (i = start; i &lt; len2; i++) {<br>        if (x -&gt; Start + i - start - temp &gt; x -&gt; End) {<br>            temp = i - start;<br>            P = x;<br>            x = x -&gt; Next[s[start + temp] - STARTCHAR];<br>            if (x == NULL) break;<br>        }<br>        if (s[i] != str[x -&gt; Start + i - start - temp]) break;<br>        result++;<br>    }<br>    P = P -&gt; Link;<br>    return result;<br>}</p>
<p>int Search(SuffixTrie &amp; h, char s[]) {<br>    int result;<br>    int i;<br>    int temp;<br>    len2 = strlen(s);<br>    result = 0;<br>    P = &amp; head;<br>    for (i = 0; i &lt; len2; i++) {<br>        temp = FindString(i + P -&gt; Length, s);<br>        if (result &lt; temp) result = temp;<br>        if (result &gt;= len2 - i) break;<br>    }<br>    return result;<br>}</p>
<p>int main() {<br>    int result;<br>    while (scanf(“%s”, str) != EOF) {<br>        Init(head, str);<br>        BuildSuffixTrie(head, str);<br>        scanf(“%s”, buf);<br>        result = Search(head, buf);<br>        printf(“%d\n”, result);<br>    }<br>}</p>
<ol>
<li>线段树</li>
</ol>
<p>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></p>
<ul>
<li>Function Name :         线段树</li>
<li>Description :              HDOJ 1542 Atlantis</li>
<li>用于表示区间线段<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<cstdio><br>#include<algorithm><br>using namespace std;</algorithm></cstdio></li>
</ul>
<p>typedef struct ITREE_NODE {<br>     ITREE_NODE <em> pLChild, </em> pRChild;<br>     double left, right;         // 左端点，右端点<br>     double measure;           // 测度<br>     int count;                     // 覆盖计数器<br>     int lines;                       // 独立线段数<br>     int lbound, rbound;      // 覆盖左、右顶点的线段数目<br>}*PITREE_NODE;</p>
<p>inline void safe_add(int &amp; v, int value) {<br>    v += value;<br>    if (v &lt; 0) v = 0;<br>}</p>
<p>void itree_splite(const double * pList, PITREE_NODE pParent, const int iLeft, const int iRight) {<br>    if (iRight - iLeft &lt;= 1) return;<br>    int iMid = (iLeft + iRight) &gt;&gt; 1;<br>    pParent -&gt; pLChild = new ITREE_NODE;<br>    pParent -&gt; pRChild = new ITREE_NODE;<br>    memset(pParent -&gt; pLChild, 0, sizeof(ITREE_NODE));<br>    memset(pParent -&gt; pRChild, 0, sizeof(ITREE_NODE));<br>    pParent -&gt; pLChild -&gt; left = pList[iLeft];<br>    pParent -&gt; pLChild -&gt; right = pList[iMid];<br>    pParent -&gt; pRChild -&gt; left = pList[iMid];<br>    pParent -&gt; pRChild -&gt; right = pList[iRight];<br>    itree_splite(pList, pParent -&gt; pLChild, iLeft, iMid);<br>    itree_splite(pList, pParent -&gt; pRChild, iMid, iRight);<br>}</p>
<p>PITREE_NODE itree_generate(const double * pList, const int iListCount) {<br>    PITREE_NODE pRoot = new ITREE_NODE;<br>    memset(pRoot, 0, sizeof(ITREE_NODE));<br>    pRoot -&gt; left = pList[0];<br>    pRoot -&gt; right = pList[iListCount - 1];<br>    itree_splite(pList, pRoot, 0, iListCount - 1);<br>    return pRoot;<br>}</p>
<p>void itree_destroy(PITREE_NODE pParent) {<br>    if (pParent == NULL) return;<br>    if (pParent -&gt; pLChild) itree_destroy(pParent -&gt; pLChild);<br>    if (pParent -&gt; pRChild) itree_destroy(pParent -&gt; pRChild);<br>    delete pParent;<br>}</p>
<p>inline void itree_measure(PITREE_NODE pNode) {<br>    if (pNode -&gt; count &gt; 0)<br>        pNode -&gt; measure = pNode -&gt; right - pNode -&gt; left;<br>    else if (pNode -&gt; pLChild &amp;&amp; pNode -&gt; pRChild)<br>        pNode -&gt; measure = pNode -&gt; pLChild -&gt; measure + pNode -&gt; pRChild -&gt; measure;<br>    else<br>          pNode -&gt; measure = 0;<br>}</p>
<p>inline void itree_lines(PITREE_NODE pNode) {<br>    if (pNode -&gt; count &gt; 0) {<br>        pNode -&gt; lines = 1;<br>    } else if (pNode -&gt; pLChild &amp;&amp; pNode -&gt; pRChild) {<br>        if (pNode -&gt; pLChild -&gt; rbound &amp;&amp; pNode -&gt; pRChild -&gt; lbound) {<br>            pNode -&gt; lines = pNode -&gt; pLChild -&gt; lines + pNode -&gt; lines - 1;<br>        } else {<br>            pNode -&gt; lines = pNode -&gt; pLChild -&gt; lines + pNode -&gt; lines;<br>        }<br>    } else {<br>        pNode -&gt; lines = 0;<br>    }<br>}</p>
<p>// 插入的时候value = 1, 删除的时候value = -1<br>void itree_update(PITREE_NODE pParent, const double left, const double right,<br>                  int value) {<br>    if (pParent -&gt; left == left &amp;&amp; pParent -&gt; right == right) {<br>        safe_add(pParent -&gt; count, value);<br>        safe_add(pParent -&gt; lbound, value);<br>        safe_add(pParent -&gt; rbound, value);<br>        itree_measure(pParent);<br>        itree_lines(pParent);<br>    } else {<br>        if (pParent -&gt; pLChild -&gt; right &gt; left) {<br>            if (pParent -&gt; pLChild -&gt; right &gt;= right) {<br>                itree_update(pParent -&gt; pLChild, left, right, value);<br>            } else {<br>                itree_update(pParent -&gt; pLChild, left,<br>                         pParent -&gt; pLChild -&gt; right, value);<br>                itree_update(pParent -&gt; pRChild, pParent -&gt; pRChild -&gt; left,<br>                         right, value);<br>            }<br>        } else {<br>            itree_update(pParent -&gt; pRChild, left, right, value);<br>        }<br>        itree_measure(pParent);<br>        itree_lines(pParent);<br>        if (left == pParent -&gt; left) safe_add(pParent -&gt; lbound, value);<br>          if (right == pParent -&gt; right) {<br>            safe_add(pParent -&gt; rbound, value);<br>        }<br>    }<br>}</p>
<p>void itree_insert(PITREE_NODE pParent, const double left, const double right) {itree_update(pParent, left, right, 1); }</p>
<p>void itree_delete(PITREE_NODE pParent, const double left, const double right) {itree_update(pParent, left, right, -1); }</p>
<p>struct EVENT {<br>     double x, y1, y2;<br>     int type;<br>};</p>
<p>bool cmp(const EVENT &amp; a, const EVENT &amp; b) </p>
<p>{ return a.x &lt; b.x; }</p>
<p>PITREE_NODE pRoot;<br>EVENT env[200];<br>double Y[200];<br>double tsize = 0.0;</p>
<p>int main() {<br>    double x1, x2, y1, y2;<br>    int i, n, n2, cas = 0;<br>    while (scanf(“%d”, &amp; n) == 1 &amp;&amp; n) {<br>        cas++;<br>        n2 = n &lt;&lt; 1;<br>        for (i = 0; i &lt; n2; i += 2) {<br>            scanf(“%lf%lf%lf%lf”, &amp; x1, &amp; y1, &amp; x2, &amp; y2);<br>            env[i].x = x1;<br>            env[i].y1 = y1;<br>            env[i].y2 = y2;<br>            env[i].type = 1;<br>            env[i + 1].x = x2;<br>            env[i + 1].y1 = y1;<br>            env[i + 1].y2 = y2;<br>            env[i + 1].type = -1;<br>            Y[i] = y1;<br>            Y[i + 1] = y2;<br>        }<br>        sort(env, env + n2, cmp);<br>        sort(Y, Y + n2);<br>        pRoot = itree_generate(Y, n2);<br>        for (i = 0; i &lt; n2; ++i) {<br>            if (i &gt; 0) tsize += pRoot -&gt; measure * (env[i].x - env[i - 1].x);<br>            else tsize = 0.0;<br>            itree_update(pRoot, env[i].y1, env[i].y2, env[i].type);<br>        }<br>        itree_destroy(pRoot);<br>        printf(“Test case #%d\nTotal explored area: %.2lf\n\n”, cas, tsize);<br>    }<br>    return 0;<br>}</p>
<ol>
<li>并查集<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li><p>Function Name :         并查集</p>
</li>
<li><p>Description :                     集合操作, 并, 除, 判断<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>const int Max=1000;<br>typedef int ElemType;</p>
</li>
</ul>
<p>int Parent[Max],Rank[Max];</p>
<p>int Find(int x)<br>{<br>    int temp = x, root, w;<br>    //搜寻根节点<br>    while(Parent[x]!=0)     x=Parent[x];<br>    root=x;<br>    x=temp;<br>     //压缩路径<br>    while(Parent[x]!=0) {<br>        w=Parent[x];<br>        Parent[x]=root;<br>        x=w;<br>    }<br>    return root;<br>}</p>
<p>int Union(int x,int y)<br>{<br>    int u, v, root;<br>    u=Find(x);<br>    v=Find(y);<br>    if(Rank[u] &lt;= Rank[v]) {<br>        root = Parent[u] = v;<br>        if(Rank[u] == Rank[v])     Rank[v]++;<br>    }<br>    else     root=Parent[v]=u;<br>    return root;<br>}</p>
<ol>
<li>二叉堆</li>
</ol>
<p>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></p>
<ul>
<li>Function Name :  二叉堆</li>
<li>Description :        父结点的键值总是大於或等於任何一个子节点的键值</li>
<li>便於寻找父节点和子节点<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>const int Max=1000;<br>typedef int ElemType;</li>
</ul>
<p>ElemType Heap[Max];</p>
<p>int Sift_Up(int i)      //上移<br>{<br>    ElemType temp;<br>    bool flag;<br>    flag = true;<br>    if(i == 1)     return 0;<br>    do {<br>        if(Heap[i] &gt; Heap[i/2])<br>        {temp=Heap[i];     Heap[i]=Heap[i/2];     Heap[i/2]=temp;}<br>        else     flag = false;<br>          i /= 2;<br>    }while(i&gt;1 || flag);<br>    return 1;<br>}</p>
<p>int Sift_Down(int i,int n)   //下移<br>{<br>    bool flag;<br>    ElemType temp;<br>    flag = false;<br>    if(2<em>i &gt; n)     return 0;<br>    do {<br>        i</em>=2;<br>        if(i+1 &lt;= n &amp;&amp; Heap[i+1] &gt; Heap[i])     i++;<br>        if(Heap[i/2] &lt; Heap[i])<br>        {temp=Heap[i];     Heap[i]=Heap[i/2];     Heap[i/2]=temp;}<br>        else     flag = false;<br>    }while(2*i&lt;=n || flag);<br>    return 1;<br>}</p>
<p>int Insert(int &amp;n,ElemType x)    //插入元素<br>{<br>    Heap[++n] = x;<br>    if( Sift_Up(n) )     return n;<br>}</p>
<p>int Delete(int &amp;n,int i)   //输出元素<br>{<br>    ElemType x,y;<br>    x = Heap[i];     y = Heap[n];<br>    n–;<br>    if(i == n+1)     return x;<br>    Heap[i] = y;<br>    if(y &gt;= x)     Sift_Up(i);<br>    else          Sift_Down(i,n);<br>    return x;<br>}</p>
<p>int Delete_Max(int &amp;n)     //输出最大值<br>{<br>    ElemType x;<br>    x = Heap[1];<br>    Delete(n,1);<br>    return x;<br>}</p>
<p>int Make_Heap(int n)    //转换为大顶堆<br>{<br>    int i;<br>    for(i=n/2; i &gt;= 1 ;i–)     Sift_Down(i,n);<br>    return n;<br>}</p>
<p>int HeapSort(int n)  //非降序排序<br>{<br>    int i;<br>    ElemType temp;<br>    Make_Heap(n);<br>    for(i=n; i &gt;= 2 ;i–) {<br>        temp=Heap[i];     Heap[i]=Heap[1];     Heap[1]=temp;<br>        Sift_Down(1,i-1);<br>    }<br>    return 1;<br>}</p>
<ol>
<li>逆序数(归并排序)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        逆序数(归并排序)</li>
<li>Description :                     N<em>Log(N)<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><em>* </em></strong></em>/<br>//逆序数值存放在anti中<br>int p[MAX], t[MAX], anti = 0;<br>void merge(int first, int last)<br>{<br>int mid = (first+last)/2;<br>int i1 = 0, i2 = first, i3 = mid+1;<br>while(i2 &lt;= mid &amp;&amp; i3 &lt;= last) {<pre><code>if(p[i2] &gt; p[i3]) {
     t[i1++] = p[i3++];
     anti += mid-i2+1;
}
else t[i1++]=p[i2++];
</code></pre>}<br>while(i2 &lt;= mid)     t[i1++] = p[i2++];<br>while(i3 &lt;= last)     t[i1++] = p[i3++];<br>i1 = first;     i2 = 0;<br>while(i2 &lt; last-first+1)     p[i1++] = t[i2++];<br>}</li>
</ul>
<p>void merge_sort(int first, int last)<br>{<br>     int mid;<br>     if(first&lt;last) {<br>          mid = (first+last)/2;<br>          merge_sort(first, mid);<br>          merge_sort(mid+1, last);<br>          merge(first, last);<br>     }<br>}</p>
<ol>
<li>树状DP<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        树状DP</li>
<li>Description :              HDOJ 1561 The more, The Better<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<cstdio><br>#include<memory><br>#include<queue><br>using namespace std;<br>#define Max 210<br>int n,m,a[Max][Max];<br>struct inf<br>{<br>int l,r,p;<br>int v;<br>}tree[Max];<br>int tp,now;<br>queue<int> SQ;<br>char v[Max];</int></queue></memory></cstdio></li>
</ul>
<p>int main()<br>{<br>    int i,j;<br>    int root,pt,tv;<br>    while(scanf(“%d%d”,&amp;n,&amp;m)) {<br>        if(n==0 &amp;&amp; m==0 )    break;<br>        memset(tree,0,sizeof(tree));<br>        memset(a,0,sizeof(a));<br>        memset(v,3,sizeof(v));<br>        while(!SQ.empty())     SQ.pop();<br>        for(i=1; i &lt;= n ;i++) {<br>            scanf(“%d%d”, &amp;root, &amp;tree[i].v);<br>            if(tree[root].l == 0) {<br>                tree[root].l = i;<br>                v[root]–;<br>                tree[i].p = root;<br>            }<br>            else {<br>                pt = tree[root].l;<br>                while(tree[pt].r != 0)     pt = tree[pt].r;<br>                tree[pt].r = i;<br>                v[pt] -= 2;<br>                tree[i].p = pt;<br>            }<br>        }<br>        for(i=1;i&lt;=n;i++)<br>            if(v[i]==3)     SQ.push(i);<br>          while(!SQ.empty()) {<br>               now = SQ.front();<br>               SQ.pop();</p>
<pre><code>           a[now][1] = tree[now].v;
           for(i=1; i &lt;= m ;i++)
                a[now][i] = a[now][i] &lt; a[ tree[now].r ][i] ? a[ tree[now].r ][i] : a[now][i];
           for(i=2; i &lt;= m ;i++)
                for(j=1; j &lt;= i ;j++) {
                     tv = a[ tree[now].l ][j-1] + tree[now].v + a[ tree[now].r ][i-j];
                     a[now][i] = a[now][i] &lt; tv ? tv : a[now][i];
                }
           if(tree[ tree[now].p ].l == now)    v[ tree[now].p ]++;
           else                                                v[ tree[now].p ] += 2;  
           if(v[ tree[now].p ] == 3) SQ.push(tree[now].p);
      }
      printf(&quot;%d\n&quot;,a[ tree[0].l ][m]);
}
</code></pre><p>}</p>
<ol>
<li>欧拉路<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        欧拉路</li>
<li>Description :              ZJU 2730 Necklace</li>
<li>欧拉路的构造方法：</li>
<li>若图连同且度为奇数的节点不超过2个,则该图可以构造出欧拉路</li>
<li>先选一个度为奇数的节点(若没有就任选一个度为偶数的节点)</li>
<li>再以该节点为起点,用dfs遍历所有的弧(每条弧只遍历一次),遇到死胡同就回溯</li>
<li>在每次回溯时将所在弧按顺序记录下来,这组弧的排列就组成了一条欧拉路<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<stdio.h><br>#define MAXN 50<br>void find_path_euler(int n, int mat[][MAXN], int now, int&amp; step, int* path)<br>{<br>int i;<br>for(i=n-1; i &gt;= 0 ;i–)<pre><code>while(mat[now][i]) {
     mat[now][i]--, mat[i][now]--;
     find_path_u(n, mat, i, step, path);
}
</code></pre>path[ step++ ]=now;<br>}</stdio.h></li>
</ul>
<p>int main()<br>{<br>     int n;<br>     int a[MAXN][MAXN];<br>     int i, j, cnt, mmin;<br>     int b[10000],c[10000];<br>     while(scanf(“%d”,&amp;n)!=EOF) {<br>          for(i=0; i&lt;n ;i++)<br>               for(j=0; j&lt;n ;j++)<br>                    if(j == i)     a[i][j] = 0;<br>                    else          a[i][j] = a[j][i] = 1;<br>          cnt = 0;<br>          mmin = 2000000000;<br>          for(i=0; i&lt;n ;i++) {<br>               find_path_u(n, a, i, cnt, b);<br>               if(cnt &lt; mmin) {<br>                    mmin = cnt;<br>                    for(j=0; j&lt;mmin ;j++)<br>                         c[j] = b[j];<br>                    break;<br>               }<br>          }<br>          printf(“%d\n”, mmin-1);<br>          for(i=0; i&lt;mmin-2 ;i++)<br>               printf(“%d “,c[i]);<br>          printf(“%d”,c[i]);<br>          printf(“\n”);<br>     }<br>}</p>
<ol>
<li>八数码<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        八数码Eight(Special Judge)</li>
<li>Description :        搜索 + 状态hash</li>
<li>PKU(1077)        HDOJ(1043)        ZOJ(1217)</li>
<li>BFS            广搜        PKU(312ms)    HDOJ(TLE)        ZOJ(TLE)</li>
<li>BFS2        双向广搜    PKU(31ms)    HDOJ(1325ms)    ZOJ(TLE)<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>#include<cstdio><br>#include<string><br>#include<memory><br>#include<queue><br>using namespace std;<br>char input[100];<br>int state[10], s_num, e10[10], fac_n[10];<br>char hash_T[400000], step[10000], hash_T2[400000];<br>struct inf<br>{<br>int pos;<br>char mode;<br>};<br>queue<int> SQ;<br>queue<inf> SQ2;</inf></int></queue></memory></string></cstdio></li>
</ul>
<p>int num_pos(int num,int x,int y)<br>{<br>    int temp=(x-1)*3+y;<br>    if(temp == num%10)    return 9;<br>    if(temp &gt; num%10)    return (num / e10[9-temp+1]) %10;<br>    else    return (num / e10[9-temp] )%10;<br>}</p>
<p>int state_pos(int num,int x,int y)<br>{<br>    int temp=(x-1)*3+y;<br>    if(temp == state[9])    return 9;<br>    if(temp &gt; state[9])    return state[temp-1];<br>    else    return state[temp];<br>}</p>
<p>inline int move(int num,char op)<br>{<br>    int t0,t1,t2;<br>    switch(op)<br>    {<br>    case ‘r’:<br>        if(num%10%3 == 0)    return 0;<br>        return num+1;<br>    case ‘l’:<br>        if((num-1)%10%3 ==0)    return 0;<br>        return num-1;<br>    case ‘u’:<br>        if(num%10 -3 &lt;= 0)    return 0;<br>        t0 = 9-num%10 + 1;<br>        t1 = num / e10[t0];<br>        t2 = t1%1000;<br>        t1= t1- t2 + (t2 % 100) <em> 10 + t2 / 100;<br>        t1</em>= e10[t0];<br>        return (t1 + ( (num % e10[t0]) - 3));<br>    case ‘d’:<br>        if(num%10 +3 &gt; 9)    return 0;<br>        t0 = 9-num%10 + 1 -3;<br>        t1 = num / e10[t0];<br>        t2 = t1%1000;<br>        t1= t1- t2 + (t2 % 10) <em> 100 + t2 / 10;<br>        t1</em>= e10[t0];<br>        return (t1 + ( (num % e10[t0]) + 3));<br>    }<br>}</p>
<p>bool be_solved()<br>{<br>    int i,j,anti=0;<br>    for(i=1;i&lt;=8;i++)<br>        for(j=1;j&lt;i;j++)<br>            if( state[i] &lt; state[j] )<br>                anti++;<br>     if(anti%2)     return false;<br>     else          return true;<br>}</p>
<p>inline int hash(int num)<br>{<br>    int dig[10],i=9,j,sum,anti;<br>    if(num==0)    return -1;<br>    while(num)    dig[i]=num%10 , num/=10 , i– ;<br>    sum=(9-dig[9])<em>fac_n[8];<br>    for(i=1;i&lt;9;i++) {<br>        for(anti=0,j=1;j&lt;i;j++)<br>            if(dig[i] &lt; dig[j])<br>                anti++;<br>          sum += anti</em>fac_n[i-1];<br>    }<br>    return sum;<br>}</p>
<p>void BFS()<br>{<br>    int k,to_num,to_hash,i;<br>    memset(hash_T,0,sizeof(hash_T));<br>    while(!SQ.empty())    SQ.pop();<br>    SQ.push(123456789);<br>    hash_T[ hash(123456789) ]=’e’;<br>    while(!SQ.empty())<br>    {<br>        k=SQ.front();<br>        SQ.pop();</p>
<pre><code>    to_num=move(k,&apos;r&apos;);    to_hash=hash(to_num);
    if(to_hash&gt;=0 &amp;&amp; hash_T[ to_hash ]==0)
        hash_T[ to_hash ]=&apos;r&apos; , SQ.push(to_num);
    to_num=move(k,&apos;l&apos;);    to_hash=hash(to_num);
    if(to_hash&gt;=0 &amp;&amp; hash_T[ to_hash ]==0)
        hash_T[ to_hash ]=&apos;l&apos; , SQ.push(to_num);
    to_num=move(k,&apos;u&apos;);    to_hash=hash(to_num);
    if(to_hash&gt;=0 &amp;&amp; hash_T[ to_hash ]==0)
        hash_T[ to_hash ]=&apos;u&apos; , SQ.push(to_num);
    to_num=move(k,&apos;d&apos;);    to_hash=hash(to_num);
    if(to_hash&gt;=0 &amp;&amp; hash_T[ to_hash ]==0)
        hash_T[ to_hash ]=&apos;d&apos; , SQ.push(to_num);
}
</code></pre><p>}</p>
<p>void BFS2()<br>{<br>    int to_num,to_hash,i;<br>    char <em>phash,</em>phash2;<br>    char op;<br>    inf k,t;<br>    memset(hash_T,0,sizeof(hash_T));<br>    memset(hash_T2,0,sizeof(hash_T2));<br>    while(!SQ2.empty())     SQ2.pop();<br>    k.pos=s_num;     k.mode=1;<br>    SQ2.push(k);<br>    k.pos=123456789;     k.mode=2;<br>    SQ2.push(k);<br>    hash_T[ hash(s_num) ]=’s’;<br>    hash_T2[ hash(123456789) ]=’e’;<br>    while(!SQ2.empty()) {<br>        k=SQ2.front();<br>        SQ2.pop();<br>        to_hash=hash(k.pos);<br>        if(k.mode==1)<br>            if(hash_T2[ to_hash ]!=0)    break;<br>            else    phash=hash_T,phash2=hash_T2;<br>               if(k.mode==2)<br>                    if(hash_T[ to_hash ]!=0)    break;<br>                    else    phash=hash_T2,phash2=hash_T;<br>               t=k;<br>               t.pos=move(k.pos,’r’);     to_hash=hash(t.pos);<br>               if(to_hash&gt;=0 &amp;&amp; phash[ to_hash ]==0)<br>                    phash[ to_hash ]=’r’ , SQ2.push(t);<br>               t.pos=move(k.pos,’l’);     to_hash=hash(t.pos);<br>               if(to_hash&gt;=0 &amp;&amp; phash[ to_hash ]==0)<br>                    phash[ to_hash ]=’l’ , SQ2.push(t);<br>               t.pos=move(k.pos,’u’);     to_hash=hash(t.pos);<br>               if(to_hash&gt;=0 &amp;&amp; phash[ to_hash ]==0)<br>                    phash[ to_hash ]=’u’ , SQ2.push(t);<br>               t.pos=move(k.pos,’d’);     to_hash=hash(t.pos);<br>               if(to_hash&gt;=0 &amp;&amp; phash[ to_hash ]==0)<br>                    phash[ to_hash ]=’d’ , SQ2.push(t);<br>    }<br>    i=0;<br>    to_hash = hash(k.pos);<br>    to_num = k.pos;<br>    while( hash_T[ to_hash ] != ‘s’ ) {<br>        switch( step[i++]=hash_T[ to_hash ] ) {<br>        case ‘r’:    op=’l’;break;<br>        case ‘l’:    op=’r’;break;<br>        case ‘u’:    op=’d’;break;<br>        case ‘d’:    op=’u’;break;<br>        }<br>        to_num=move(to_num,op);<br>        to_hash=hash(to_num);<br>    }<br>    while(i&gt;0)     printf(“%c”,step[–i]);<br>    to_hash=hash(k.pos);<br>    to_num=k.pos;<br>    while( hash_T2[ to_hash ]!=’e’ ) {<br>        switch( hash_T2[ to_hash ] ) {<br>        case ‘r’:    op=’l’;break;<br>        case ‘l’:    op=’r’;break;<br>        case ‘u’:    op=’d’;break;<br>        case ‘d’:    op=’u’;break;<br>        }<br>        printf(“%c”,op);<br>        to_num=move(to_num, op );<br>        to_hash=hash(to_num);<br>    }<br>}</p>
<p>int main()<br>{<br>    int i,j;<br>    for(e10[0]=1,i=1;i&lt;=9;i++)<br>        e10[i] =e10[i-1]<em>10;<br>    for(fac_n[0]=0,fac_n[1]=1,i=2;i&lt;=9;i++)<br>        fac_n[i] =fac_n[i-1]</em>i;<br>    while( gets(input) ) {<br>        for(i=strlen(input)-1,j=8;i&gt;=0;i–) {<br>            if(input[i]!=’ ‘) {<br>                if(input[i]==’x’)<br>                    state[9]=j+1;<br>                else state[j–]=input[i]-‘0’;<br>            }<br>        }<br>        for(s_num=0,i=9,j=1;i&gt;0;i–,j<em>=10)<br>            s_num += state[i]</em>j;<br>        if( !be_solved() )<br>            printf(“unsolvable\n”);<br>        else {<br>            BFS2();<br>            printf(“\n”);<br>        }<br>    }<br>}</p>
<ol>
<li>高斯消元法<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :          高斯消元法</li>
<li>Description :             求解线性方程组<br>*</li>
<li>void exchange_col(int p1,int p2,int n)  </li>
<li>交换p1行和p2行的所有数据<br>*</li>
<li>bool gauss(int n)</li>
<li>求解系数矩阵为n的线性方程组，方程组无解返回false，否则true<br>*</li>
<li>x1 = x0 - f(x0)/f’(x0)   牛顿迭代法<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>const int num = 100;<br>double matrix[num][num + 1];   //系数矩阵，从0开始<br>double ans[num];               //结果数组</li>
</ul>
<p>void exchange_col(int p1,int p2,int n)  //交换p1行和p2行的所有数据<br>{<br>     double t;<br>     int i;</p>
<pre><code>for(i = 0 ; i &lt;= n ; i++)
     t = matrix[p1][i],matrix[p1][i] = matrix[p2][i],matrix[p2][i] = t;
</code></pre><p>}</p>
<p>bool gauss(int n)   //求解系数矩阵为n的线性方程组<br>{<br>     int i,j,k;<br>     int p;<br>     double r;</p>
<pre><code>for(i = 0 ; i &lt; n - 1 ; i++) {
     p = i;
     for(j = i + 1 ; j &lt; n ; j++) {   //寻找i列最大值位置
          if(matrix[j][i] &gt; matrix[p][i])
               p = j;
     }
     if(matrix[p][i] == 0) return false;
     if(p != i)     exchange_col(i,p,n);
     for(j = i + 1 ; j &lt; n ; j++) {       //剩余列进行消元
          r = matrix[j][i] / matrix[i][i];
          for(k = i ; k &lt;= n ; k++)
               matrix[j][k] -= r * matrix[i][k];
     }
}
for(i = n - 1 ; i &gt;= 0 ; i--) {   //获得结果
     ans[i] = matrix[i][n];
     for(j = n - 1 ; j &gt; i ; j--)
          ans[i] -= matrix[i][j] * ans[j];
     ans[i] /= matrix[i][i];
}
return true;
</code></pre><p>}</p>
<ol>
<li>字符串匹配(KMP算法)<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        字符串匹配(KMP算法)</li>
<li><p>Description :        O(N+M)<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>void get_nextval(const string &amp; s, int * p)<br>{<br>int i = 0,j = -1;<br>p[0] = -1;<br>while(i &lt; s.size()) {</p>
<pre><code>if(j == -1 || s[i] == s[j]) {
     ++i,++j;
     if(s[i] != s[j]) p[i] = j;
     else
          p[i] = p[j];     
}
else j = p[j];
</code></pre><p>}<br>}<br>int Index_KMP(const string &amp; s, const string &amp; s1, int pos)<br>{<br>int i = pos - 1,j = 0;<br>int * next = new int[s1.size()];</p>
<p>get_nextval(s1,next);<br>while(i &lt;= s.size() &amp;&amp; j &lt;= s1.size()) {</p>
<pre><code>if(j == -1 || s[i] == s1[j])     ++i,++j;
else     j = next[j];
</code></pre><p>}<br>if(j &gt; s1.size())     return i - s1.size();<br>else     return -1;<br>}</p>
</li>
</ul>
<ol>
<li>全排列,全组合<br>/<strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong></li>
</ol>
<ul>
<li>Function Name :        全排列,全组合<br><strong><strong> </strong></strong> <strong><strong> </strong></strong> <strong><strong> </strong></strong>/<br>void createper(int n) //全排列<br>{<br>int total,i,j,k,t,*a=new int[n],top;<br>total=1;<br>for(i=1;i&lt;=n;i++) {<pre><code>a[i]=i;
total*=i;
</code></pre>}<br>for(i=1;i&lt;n;i++)     printf(“%d “,a[i]);<br>printf(“%d\n”,a[n]);<br>for(i=1;i&lt;total;i++) {<pre><code>j=n;
while(a[j]&lt;a[j-1]) j--;
k=n;
while(a[j-1]&gt;a[k]) k--;
t=a[j-1];
a[j-1]=a[k];
a[k]=t;
top=(j+n-1)/2;
for(k=j;k&lt;=top;k++) {
     t=a[k];
     a[k]=a[n-k+j];
     a[n-k+j]=t;
}
for(j=1;j&lt;n;j++) printf(&quot;%d &quot;,a[j]);
printf(&quot;%d\n&quot;,a[n]);
</code></pre>}<br>}</li>
</ul>
<p>void createfab(int m,int n) //全组合<br>{<br>     int i,j,lcount,*a=new int[n+2];<br>     for(i=1;i&lt;=n;i++)     a[i]=i;<br>     a[n+1]=m+1;<br>     for(j=1;j<n;j++) printf("%d="" ",a[j]);="" printf("%d\n",a[n]);="" lcount="1;" while(a[1]<m-n+1)="" {="" for(i="n;i">0;i–) {<br>               if(a[i]&lt;a[i+1]-1) {<br>                    a[i]++;<br>                    for(j=i;j&lt;n;j++)     a[j+1]=a[j]+1;<br>                    for(j=1;j&lt;n;j++)     printf(“%d “,a[j]);<br>                    printf(“%d\n”,a[n]);<br>                    lcount++;<br>                    break;<br>               }<br>          }<br>     }<br>}</n;j++)></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/The-Evaluation-of-Determinant-求行列式mod一个数的值）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/The-Evaluation-of-Determinant-求行列式mod一个数的值）/" itemprop="url">
                  The Evaluation of Determinant(求行列式mod一个数的值）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:12:48-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">LL n,m,A[<span class="number">105</span>][<span class="number">105</span>],p[<span class="number">10000</span>],pos,d[<span class="number">105</span>],r[<span class="number">105</span>],len,B[<span class="number">105</span>][<span class="number">105</span>];</div><div class="line"><span class="keyword">bool</span> vd[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    pos=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">10005</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(!vd[i])</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1000</span>) p[pos++]=i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=(i&lt;&lt;<span class="number">1</span>);j&lt;<span class="number">10005</span>;j+=i)</div><div class="line">                vd[i]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">(LL k)</span></span></div><div class="line">&#123;</div><div class="line">    len=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pos&amp;&amp;k!=<span class="number">1</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(k%p[i]==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(k%p[i]==<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                d[len++]=p[i];</div><div class="line">                k/=p[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function">LL <span class="title">exp</span><span class="params">(LL a,LL b,LL mod)</span></span></div><div class="line">&#123;</div><div class="line">    LL ans=<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%mod;</div><div class="line">        a=a*a%mod;b&gt;&gt;=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex_gcd</span><span class="params">(LL a,LL b,LL &amp;dd,LL &amp;x,LL &amp;y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</div><div class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>,dd=a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        ex_gcd(b,a%b,dd,y,x);</div><div class="line">        y-=x*(a/b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function">LL <span class="title">gauss</span><span class="params">(LL mod)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</div><div class="line">    LL ans=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">            B[i][j]=A[i][j];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n<span class="number">-1</span>;k++)</div><div class="line">    &#123;</div><div class="line">        LL max_b=B[k][k];<span class="keyword">int</span> bin=k;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;n;i++)</div><div class="line">            <span class="keyword">if</span>(B[i][k]&gt;max_b)</div><div class="line">                max_b=B[i][k],bin=i;</div><div class="line">        <span class="keyword">if</span>(bin!=k)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++)</div><div class="line">                swap(B[bin][i],B[k][i]);</div><div class="line">            flag^=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(B[k][k]&lt;<span class="number">0</span>)B[k][k]+=mod;</div><div class="line">        LL Ni,y,dd;</div><div class="line">        ex_gcd(B[k][k],mod,dd,Ni,y);</div><div class="line">        Ni%=mod;</div><div class="line">        <span class="keyword">if</span>(Ni&lt;<span class="number">0</span>)Ni+=mod;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;n;j++)</div><div class="line">        &#123;</div><div class="line">            B[k][j]=B[k][j]*Ni%mod;</div><div class="line">            <span class="keyword">if</span>(B[k][j]&lt;<span class="number">0</span>)B[k][j]+=mod;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;n;i++)</div><div class="line">            &#123;</div><div class="line">                B[i][j]=(B[i][j]-(B[k][j]*B[i][k])%mod)%mod;</div><div class="line">                <span class="keyword">if</span>(B[i][j]&lt;<span class="number">0</span>)B[i][j]+=mod;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ans*=B[k][k];</div><div class="line">        ans%=mod;</div><div class="line">        <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans+=mod;</div><div class="line">    &#125;</div><div class="line">    ans*=B[n<span class="number">-1</span>][n<span class="number">-1</span>];</div><div class="line">    ans%=mod;</div><div class="line">    <span class="keyword">if</span>(flag)ans=-ans;</div><div class="line">    <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans+=mod;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">LL <span class="title">china_remain</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    LL a,b,c,c1,c2,x,y,dd,N;</div><div class="line">    a=d[<span class="number">0</span>],c1=r[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span>(c1==<span class="number">0</span>)c1=d[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</div><div class="line">    &#123;</div><div class="line">        b=d[i],c2=r[i];</div><div class="line">        ex_gcd(a,b,dd,x,y);</div><div class="line">        c=c2-c1;</div><div class="line">        LL b1=b/dd;</div><div class="line">        x=((c/dd*x)%b1+b1)%b1;</div><div class="line">        c1=a*x+c1;</div><div class="line">        a=a*b1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c1%m;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    prime();</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">    &#123;</div><div class="line">        deal(m);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">                <span class="built_in">cin</span>&gt;&gt;A[i][j];</div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</div><div class="line">        &#123;</div><div class="line">            r[i]=gauss(d[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;china_remain()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/HDU1565-方格取数1（构图-网络流最大独立集合）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/HDU1565-方格取数1（构图-网络流最大独立集合）/" itemprop="url">
                  HDU1565 方格取数1（构图+网络流最大独立集合）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:10:20-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>题目大意：给你一个n*n的格子的棋盘，每个格子里面有一个非负数。<br>从中取出若干个数，使得任意的两个数所在的格子没有公共边，就是说所取的数所在的2个格子不能相邻，并且取出的数的和最大。</p>
<p>解题思路：最大点权独立集，关键是怎么建图了，我们可以采用染色的思想对这张图进行染色，然后分成两个点集<br>假设将第一个格子染成白色，然后将它相邻的格子染成相反的颜色黑色，以此类推，这样就可以将一张图分成染成黑白两种颜色的点集了<br>然后就是连边了，连边的话，我们只考虑白色格子的连向黑色格子的，因为两者之间是相对的，所以只需要取一条就好了<br>这样图就建好了<br>最大独立集就是:总权值-最小割了(最小割就是最小点权覆盖了)</p>
<p>最小割即最大流<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> n,a[<span class="number">21</span>][<span class="number">21</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXE 1100000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></div><div class="line"><span class="keyword">int</span> ne,nv,s,t;</div><div class="line"><span class="keyword">int</span> size,net[MAXN];</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> v,next;</div><div class="line">    <span class="keyword">int</span> cap;</div><div class="line">    <span class="keyword">int</span> flow;</div><div class="line">&#125;edge[MAXE];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    size=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(net,<span class="number">-1</span>,<span class="keyword">sizeof</span>(net));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)</span></span>&#123;</div><div class="line">    <span class="comment">//cout&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;cap&lt;&lt;endl;</span></div><div class="line">    ne++;</div><div class="line">    edge[size].v = v;</div><div class="line">    edge[size].cap = cap;</div><div class="line">    edge[size].flow = <span class="number">0</span>;</div><div class="line">    edge[size].next = net[u];</div><div class="line">    net[u] = size;</div><div class="line">    ++size;</div><div class="line">    </div><div class="line">    edge[size].v = u;</div><div class="line">    edge[size].cap = <span class="number">0</span>;</div><div class="line">    edge[size].flow = <span class="number">0</span>;</div><div class="line">    edge[size].next = net[v];</div><div class="line">    net[v] = size;</div><div class="line">    ++size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> gap[MAXN];<span class="comment">//gap优化</span></div><div class="line"><span class="keyword">int</span> dist[MAXN];<span class="comment">//距离标号</span></div><div class="line"><span class="keyword">int</span> pre[MAXN];<span class="comment">//前驱</span></div><div class="line"><span class="keyword">int</span> curedge[MAXN];<span class="comment">//当前弧</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> cur_flow,u,temp,neck,i;</div><div class="line">    <span class="keyword">int</span> max_flow;</div><div class="line">    <span class="built_in">memset</span>(gap,<span class="number">0</span>,<span class="keyword">sizeof</span>(gap));</div><div class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="keyword">sizeof</span>(pre));</div><div class="line">    <span class="built_in">memset</span>(dist,<span class="number">0</span>,<span class="keyword">sizeof</span>(dist));</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=nv;i++) curedge[i]=net[i];<span class="comment">//将当前弧初始话成邻接表的第一条边</span></div><div class="line">    gap[nv]=nv;</div><div class="line">    max_flow=<span class="number">0</span>;</div><div class="line">    u=s;</div><div class="line">    <span class="keyword">while</span>(dist[s]&lt;nv)&#123;</div><div class="line">        <span class="keyword">if</span>(u==t)&#123;<span class="comment">//找到一条增广路</span></div><div class="line">            cur_flow=INF;</div><div class="line">            <span class="keyword">for</span>(i=s;i!=t;i=edge[curedge[i]].v)&#123;<span class="comment">//沿着增广路找到最小增广流量</span></div><div class="line">                <span class="keyword">if</span>(cur_flow&gt;edge[curedge[i]].cap)&#123;</div><div class="line">                    neck=i;</div><div class="line">                    cur_flow=edge[curedge[i]].cap;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(i=s;i!=t;i=edge[curedge[i]].v)&#123;<span class="comment">//更新</span></div><div class="line">                temp=curedge[i];</div><div class="line">                edge[temp].cap-=cur_flow;</div><div class="line">                edge[temp].flow+=cur_flow;</div><div class="line">                temp^=<span class="number">1</span>;</div><div class="line">                edge[temp].cap+=cur_flow;</div><div class="line">                edge[temp].flow-=cur_flow;</div><div class="line">            &#125;</div><div class="line">            max_flow+=cur_flow;</div><div class="line">            u=neck;<span class="comment">//下次直接从关键边的u开始新一轮的增广</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(i=curedge[u];i!=<span class="number">-1</span>;i=edge[i].next)<span class="comment">//找到一条允许弧</span></div><div class="line">            <span class="keyword">if</span>(edge[i].cap&gt;<span class="number">0</span>&amp;&amp;dist[u]==dist[edge[i].v]+<span class="number">1</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(i!=<span class="number">-1</span>)&#123;<span class="comment">//如果找到 将u指向v</span></div><div class="line">            curedge[u]=i;</div><div class="line">            pre[edge[i].v]=u;</div><div class="line">            u=edge[i].v;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;<span class="comment">//找不到</span></div><div class="line">            <span class="keyword">if</span>(<span class="number">0</span>==--gap[dist[u]]) <span class="keyword">break</span>;<span class="comment">//出现断层</span></div><div class="line">            curedge[u] = net[u];<span class="comment">//把当前弧重新设为邻接表中满足要求的第一条弧</span></div><div class="line">            <span class="keyword">for</span>(temp=nv,i=net[u];i!=<span class="number">-1</span>;i=edge[i].next)</div><div class="line">                <span class="keyword">if</span>(edge[i].cap &gt; <span class="number">0</span>)</div><div class="line">                    temp=temp&lt;dist[edge[i].v]?temp:dist[edge[i].v];</div><div class="line">            dist[u]=temp+<span class="number">1</span>;<span class="comment">//将这个点的距离标号设为由它出发的所有弧的终点的距离标号的最小值加1</span></div><div class="line">            ++gap[dist[u]];</div><div class="line">            <span class="keyword">if</span>(u!=s)u=pre[u];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//cout&lt;&lt;max_flow&lt;&lt;endl;</span></div><div class="line">    <span class="keyword">return</span> max_flow;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        init();</div><div class="line">        <span class="keyword">int</span> i,j,sum=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]),sum+=a[i][j];</div><div class="line">        ne=<span class="number">0</span>;</div><div class="line">        nv=n*n+<span class="number">2</span>;</div><div class="line">        s=<span class="number">1</span>;</div><div class="line">        t=n*n+<span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">                <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>) add(n*(i<span class="number">-1</span>)+j+<span class="number">1</span>,n*n+<span class="number">2</span>,a[i][j]); <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    add(<span class="number">1</span>,n*(i<span class="number">-1</span>)+j+<span class="number">1</span>,a[i][j]);</div><div class="line">                    <span class="keyword">if</span> (i&gt;<span class="number">1</span>) add(n*(i<span class="number">-1</span>)+j+<span class="number">1</span>,n*(i<span class="number">-2</span>)+j+<span class="number">1</span>,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>);</div><div class="line">                    <span class="keyword">if</span> (i&lt;n) add(n*(i<span class="number">-1</span>)+j+<span class="number">1</span>,n*i+j+<span class="number">1</span>,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>);</div><div class="line">                    <span class="keyword">if</span> (j&gt;<span class="number">1</span>) add(n*(i<span class="number">-1</span>)+j+<span class="number">1</span>,n*(i<span class="number">-1</span>)+j,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>);</div><div class="line">                    <span class="keyword">if</span> (j&lt;n) add(n*(i<span class="number">-1</span>)+j+<span class="number">1</span>,n*(i<span class="number">-1</span>)+j+<span class="number">2</span>,(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>);</div><div class="line">                 &#125;</div><div class="line">        <span class="comment">//cout&lt;&lt;nv&lt;&lt;" "&lt;&lt;ne&lt;&lt;endl;</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum-ISAP());</div><div class="line">     &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/HDU1530（最大团）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/HDU1530（最大团）/" itemprop="url">
                  HDU1530（最大团）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:05:55-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Given a graph G(V, E), a clique is a sub-graph g(v, e), so that for all vertex pairs v1, v2 in v, there exists an edge (v1, v2) in e. Maximum clique is the clique that has maximum number of vertex.<br>问题描述：团就是最大完全子图。</p>
<p>给定无向图G=(V,E)。如果UV，且对任意u，vU 有(u，v)  E，则称U 是G 的完全子图。</p>
<p>G 的完全子图U是G的团当且仅当U不包含在G 的更大的完全子图中，即U就是最大完全子图。</p>
<p>G 的最大团是指G中所含顶点数最多的团。</p>
<p>这里可使用加入DP后的优化算法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> n,path[<span class="number">61</span>][<span class="number">61</span>],s[<span class="number">61</span>],ans,dp[<span class="number">61</span>];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_clique</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> end,<span class="keyword">const</span> <span class="keyword">int</span> point)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;end;i++)</div><div class="line">        <span class="keyword">if</span> (!path[s[i]][point]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth,<span class="keyword">int</span> now)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (depth+n-now+<span class="number">1</span>&lt;=ans||depth+dp[now]&lt;=ans) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i=now;i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (is_clique(depth+<span class="number">1</span>,i))</div><div class="line">        &#123;</div><div class="line">            s[depth+<span class="number">1</span>]=i;</div><div class="line">            dfs(depth+<span class="number">1</span>,i+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (depth&gt;ans) ans=depth;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">int</span> i,j;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;path[i][j]);</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        ans=<span class="number">0</span>;</div><div class="line">        dp[n]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</div><div class="line">        &#123;</div><div class="line">            s[<span class="number">1</span>]=i;</div><div class="line">            dfs(<span class="number">1</span>,i+<span class="number">1</span>);</div><div class="line">            dp[i]=ans;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/03/HDU1914（稳定婚姻）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hnqw1214">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="acmclub.win">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/03/HDU1914（稳定婚姻）/" itemprop="url">
                  HDU1914（稳定婚姻）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T16:00:06-04:00">
                2017-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[题目链接]<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1914" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1914</a></p>
<p>思路：Gale-Shapley算法。算法过程是男士不停地求婚，女士不停地拒绝。在每一轮中，每个尚未订婚的男士在他还没有求过婚的女士中选一个自己最喜欢的求婚（不管她有没有订婚）。然后每个女士在向她求婚的人之中选择她最喜欢的一个订婚，并且拒绝其他人。注意，这些向她求婚的人中包含她的未婚夫，因此她可以选择另一个自己更喜欢的人订婚，而抛弃自己的现任未婚夫。这个算法的结果是使男士都能娶到自己有可能娶到的最好的妻子，所以是对男士的理想配对。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">male</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> f,rev[<span class="number">41</span>],tag;</div><div class="line">&#125; m[<span class="number">41</span>];</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">female</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> tag,temp,val,wait[<span class="number">41</span>];</div><div class="line">&#125; f[<span class="number">41</span>];</div><div class="line"><span class="keyword">int</span> _,n,t,k,mf[<span class="number">41</span>][<span class="number">41</span>],fm[<span class="number">41</span>][<span class="number">41</span>];</div><div class="line"><span class="keyword">char</span> ch[<span class="number">41</span>];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</div><div class="line">        <span class="keyword">if</span> (m[i].f==<span class="number">0</span>&amp;&amp;m[i].tag&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);</div><div class="line">    <span class="keyword">while</span> (_--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">int</span> i,j;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</div><div class="line">        &#123;</div><div class="line">            f[i].tag=<span class="number">0</span>;</div><div class="line">            m[i].tag=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</div><div class="line">            t=ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>;</div><div class="line">            m[t].f=<span class="number">0</span>;</div><div class="line">            m[t].tag=t;</div><div class="line">            <span class="built_in">memset</span>(m[t].rev,<span class="number">0</span>,<span class="keyword">sizeof</span>(m[t].rev));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</div><div class="line">            t=ch[<span class="number">0</span>]-<span class="string">'A'</span>+<span class="number">1</span>;</div><div class="line">            f[t].tag=t;</div><div class="line">            f[t].temp=<span class="number">0</span>;</div><div class="line">            f[t].val=<span class="number">30</span>;</div><div class="line">            <span class="built_in">memset</span>(f[t].wait,<span class="number">0</span>,<span class="keyword">sizeof</span>(f[i].wait));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</div><div class="line">            t=ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;=n+<span class="number">1</span>;j++)</div><div class="line">                mf[t][j<span class="number">-1</span>]=ch[j]-<span class="string">'A'</span>+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//cout&lt;&lt;1;</span></div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</div><div class="line">            t=ch[<span class="number">0</span>]-<span class="string">'A'</span>+<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (j=<span class="number">2</span>;j&lt;=n+<span class="number">1</span>;j++)</div><div class="line">                fm[t][j<span class="number">-1</span>]=ch[j]-<span class="string">'a'</span>+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//cout&lt;&lt;"hhhhhhh"&lt;&lt;endl;</span></div><div class="line">        <span class="keyword">while</span> (ok())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (m[i].f==<span class="number">0</span>&amp;&amp;m[i].tag&gt;<span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">                    &#123;</div><div class="line">                        t=mf[i][j];</div><div class="line">                        <span class="keyword">if</span> (m[i].rev[t]==<span class="number">0</span>)</div><div class="line">                        &#123;</div><div class="line">                            m[i].rev[t]=<span class="number">1</span>;</div><div class="line">                            m[i].f=<span class="number">1</span>;</div><div class="line">                            k=++f[t].wait[<span class="number">0</span>];</div><div class="line">                            f[t].wait[k]=i;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (f[i].tag&gt;<span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=f[i].wait[<span class="number">0</span>];j++)</div><div class="line">                    &#123;</div><div class="line">                        t=f[i].wait[j];</div><div class="line">                        <span class="keyword">for</span> (k=<span class="number">1</span>;k&lt;=n;k++)</div><div class="line">                            <span class="keyword">if</span> (fm[i][k]==t) <span class="keyword">break</span>;</div><div class="line">                        <span class="keyword">if</span> (f[i].val&gt;k)</div><div class="line">                        &#123;</div><div class="line">                            m[f[i].temp].f=<span class="number">0</span>;</div><div class="line">                            f[i].temp=t;</div><div class="line">                            f[i].val=k;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> m[t].f=<span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                    f[i].wait[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> out[<span class="number">41</span>];</div><div class="line">        <span class="built_in">memset</span>(out,<span class="number">0</span>,<span class="keyword">sizeof</span>(out));</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</div><div class="line">            <span class="keyword">if</span> (f[i].tag&gt;<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                j=f[i].temp;</div><div class="line">                out[j]=i;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</div><div class="line">            <span class="keyword">if</span> (out[i]) <span class="built_in">printf</span>(<span class="string">"%c %c\n"</span>,i<span class="number">-1</span>+<span class="string">'a'</span>,out[i]<span class="number">-1</span>+<span class="string">'A'</span>);</div><div class="line">        <span class="keyword">if</span> (_) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/8E9212F83525E2181D28AA0DBE0BF1D7.jpg"
               alt="hnqw1214" />
          <p class="site-author-name" itemprop="name">hnqw1214</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hnqw1214</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
